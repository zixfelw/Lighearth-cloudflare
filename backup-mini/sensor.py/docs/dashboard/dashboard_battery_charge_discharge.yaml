type: custom:apexcharts-card
header:
  title: Battery Charge & Discharge
  show: true
graph_span: 24h
span:
  start: day
now:
  show: false
apex_config:
  chart:
    type: area
    height: 300
    toolbar:
      show: true
      tools:
        download: true
        selection: true
        zoom: true
        zoomin: true
        zoomout: true
        pan: true
        reset: true
  xaxis:
    type: datetime
    labels:
      format: HH:mm
      rotate: -45
  yaxis:
    - title:
        text: Power (W)
        style:
          fontSize: 12px
  legend:
    position: top
    horizontalAlign: right
    fontSize: 12px
    formatter: |
      EVAL:function(seriesName, opts) {
        return seriesName;
      }
  tooltip:
    shared: true
    intersect: false
    y:
      formatter: |
        EVAL:function(val) {
          return Math.abs(val) + ' W';
        }
  fill:
    opacity: 0.3
card_mod:
  style: |
    ha-card {
      background: var(--card-background-color);
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
series:
  - entity: sensor.device_h240909079_charge_today
    name: Charge
    type: area
    color: "#FF9800"
    stroke_width: 2
    data_generator: |
      return (function() {
        const attr = entity.attributes.series_5min_w || [];
        const arr = typeof attr === 'string' ? attr.split(',').map(function(x) { return parseFloat(x.trim()) || 0; }) : attr;
        if (!arr || arr.length === 0) return [];
        
        const now = new Date();
        const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
        const currentTime = now.getTime();
        
        // Get real-time battery power from MQTT sensor if available
        const batteryPowerEntityId = 'sensor.device_h240909079_battery_power';
        const batteryStatusEntityId = 'sensor.device_h240909079_battery_status';
        let realtimeCharge = 0;
        
        try {
          const batteryPowerState = states[batteryPowerEntityId];
          const batteryStatusState = states[batteryStatusEntityId];
          
          if (batteryPowerState && batteryStatusState && batteryPowerState.state !== 'unavailable' && batteryStatusState.state !== 'unavailable') {
            const batteryPower = parseFloat(batteryPowerState.state) || 0;
            const batteryStatus = batteryStatusState.state || '';
            
            // Charge shows as positive (above 0), Discharge shows as negative (below 0)
            // Battery power is absolute value, status tells us charge/discharge
            if (batteryStatus === 'Charging' && batteryPower > 0) {
              // Keep positive for charge (show above 0)
              realtimeCharge = Math.min(Math.max(batteryPower, 0), 4000);       
            }
          }
        } catch (e) {
          // Ignore errors if entities don't exist
        }

        const dataPoints = arr.map(function(value, index) {
          const hours = Math.floor(index / 12);
          const minutes = (index % 12) * 5;
          const timestamp = new Date(startOfDay);
          timestamp.setHours(hours, minutes, 0, 0);
          const val = parseFloat(value) || 0;
          // Charge values are positive from backend (show above 0)
          // Clamp to 0-4000 range
          return [timestamp.getTime(), Math.min(Math.max(val, 0), 4000)];
        });
        
        // Add real-time point if we have current data and it's after the last data point                                                                       
        if (realtimeCharge > 0 && dataPoints.length > 0) {
          const lastPoint = dataPoints[dataPoints.length - 1];
          const lastTime = lastPoint[0];
          // Only add if current time is after last data point
          if (currentTime > lastTime) {
            dataPoints.push([currentTime, realtimeCharge]);
          }
        }
        
        return dataPoints;
      })();
  - entity: sensor.device_h240909079_discharge_today
    name: Discharge
    type: area
    color: "#4CAF50"
    stroke_width: 2
    data_generator: |
      return (function() {
        const attr = entity.attributes.series_5min_w || [];
        const arr = typeof attr === 'string' ? attr.split(',').map(function(x) { return parseFloat(x.trim()) || 0; }) : attr;
        if (!arr || arr.length === 0) return [];
        
        const now = new Date();
        const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
        const currentTime = now.getTime();
        
        // Get real-time battery power from MQTT sensor if available
        const batteryPowerEntityId = 'sensor.device_h240909079_battery_power';
        const batteryStatusEntityId = 'sensor.device_h240909079_battery_status';
        let realtimeDischarge = 0;
        
        try {
          const batteryPowerState = states[batteryPowerEntityId];
          const batteryStatusState = states[batteryStatusEntityId];
          
          if (batteryPowerState && batteryStatusState && batteryPowerState.state !== 'unavailable' && batteryStatusState.state !== 'unavailable') {
            const batteryPower = parseFloat(batteryPowerState.state) || 0;
            const batteryStatus = batteryStatusState.state || '';
            
            // Charge shows as positive (above 0), Discharge shows as negative (below 0)
            // Battery power is absolute value, status tells us charge/discharge
            if (batteryStatus === 'Discharging' && batteryPower > 0) {
              // Invert to negative for discharge (show below 0)
              realtimeDischarge = -Math.min(Math.max(batteryPower, 0), 3000);
            }
          }
        } catch (e) {
          // Ignore errors if entities don't exist
        }

        const dataPoints = arr.map(function(value, index) {
          const hours = Math.floor(index / 12);
          const minutes = (index % 12) * 5;
          const timestamp = new Date(startOfDay);
          timestamp.setHours(hours, minutes, 0, 0);
          const val = parseFloat(value) || 0;
          // Discharge values are negative from backend (show below 0)
          // Clamp to -3000 to 0 range
          return [timestamp.getTime(), Math.max(Math.min(val, 0), -3000)];
        });
        
        // Add real-time point if we have current data and it's after the last data point
        if (realtimeDischarge < 0 && dataPoints.length > 0) {
          const lastPoint = dataPoints[dataPoints.length - 1];
          const lastTime = lastPoint[0];
          // Only add if current time is after last data point
          if (currentTime > lastTime) {
            dataPoints.push([currentTime, realtimeDischarge]);
          }
        }
        
        return dataPoints;
      })();
