<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LightEarth Bot v2.7 - Copy Full Code</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #22d3ee; text-align: center; margin-bottom: 10px; font-size: 28px; }
    .subtitle { color: #a78bfa; text-align: center; margin-bottom: 20px; }
    .badges { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; margin-bottom: 20px; }
    .badge { background: #059669; color: white; padding: 4px 10px; border-radius: 20px; font-size: 11px; }
    .badge.purple { background: #7c3aed; }
    .badge.blue { background: #0ea5e9; }
    .badge.orange { background: #ea580c; }
    
    .features { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
      gap: 15px; 
      margin-bottom: 25px; 
    }
    .feature-card {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 10px;
      padding: 15px;
      border: 1px solid #334155;
    }
    .feature-card h3 { color: #22d3ee; font-size: 14px; margin-bottom: 8px; }
    .feature-card ul { list-style: none; font-size: 12px; line-height: 1.6; }
    .feature-card li::before { content: "‚Ä¢ "; color: #10b981; }
    
    .copy-section { 
      background: rgba(30, 41, 59, 0.9); 
      border-radius: 12px; 
      padding: 15px; 
      margin-bottom: 20px;
      border: 1px solid #334155;
    }
    .copy-header { 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .copy-header h2 { color: #a78bfa; font-size: 16px; }
    .copy-btn {
      background: linear-gradient(135deg, #22d3ee 0%, #0ea5e9 100%);
      color: #0f172a;
      border: none;
      padding: 10px 25px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }
    .copy-btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(34, 211, 238, 0.4); }
    .copy-btn.copied { background: linear-gradient(135deg, #10b981 0%, #059669 100%); }
    
    .code-container {
      background: #0f172a;
      border-radius: 8px;
      padding: 12px;
      max-height: 500px;
      overflow: auto;
      border: 1px solid #1e293b;
    }
    .code-container pre {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 11px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-all;
      color: #94a3b8;
    }
    
    .info-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .info-card {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 10px;
      padding: 15px;
      border: 1px solid #334155;
    }
    .info-card h3 { color: #f97316; font-size: 14px; margin-bottom: 10px; }
    .info-card ol { padding-left: 18px; font-size: 12px; line-height: 1.8; }
    .info-card code { 
      background: #0f172a; 
      padding: 2px 6px; 
      border-radius: 4px; 
      font-size: 11px;
      color: #22d3ee;
    }
    
    .sample-notifs {
      background: #1e1e1e;
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      margin-top: 8px;
      border-left: 3px solid #22d3ee;
    }
    
    .footer { text-align: center; margin-top: 25px; color: #64748b; font-size: 11px; }
    
    @media (max-width: 600px) {
      h1 { font-size: 22px; }
      .code-container { max-height: 300px; }
      .code-container pre { font-size: 9px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ü§ñ LightEarth Bot v2.7</h1>
    <p class="subtitle">COMPACT + DETAILED HOURLY</p>
    
    <div class="badges">
      <span class="badge">üìã Th√¥ng b√°o G·ªçn</span>
      <span class="badge purple">‚è∞ B√°o c√°o Gi·ªù Chi ti·∫øt</span>
      <span class="badge blue">üîå Voltage Alerts</span>
      <span class="badge orange">üîó Deep Link ‚â§64</span>
    </div>
    
    <div class="features">
      <div class="feature-card">
        <h3>üìã Th√¥ng b√°o Ng∆∞·ª°ng (G·ªçn)</h3>
        <ul>
          <li>Pin ƒë·∫ßy: 97% (ng∆∞·ª°ng: 95%)</li>
          <li>Pin th·∫•p: 18% (ng∆∞·ª°ng: 20%)</li>
          <li>ƒêi·ªán √°p cao: 54.5V (ng∆∞·ª°ng: 54V)</li>
          <li>ƒêi·ªán √°p th·∫•p: 48.5V (ng∆∞·ª°ng: 49V)</li>
          <li>PV: 25kWh (ng∆∞·ª°ng: 20kWh)</li>
          <li>EVN: 5.5kWh (ng∆∞·ª°ng: 5kWh)</li>
          <li>Ti√™u th·ª•: 15kWh (ng∆∞·ª°ng: 12kWh)</li>
        </ul>
      </div>
      <div class="feature-card">
        <h3>‚è∞ B√°o c√°o M·ªói Gi·ªù (Chi ti·∫øt)</h3>
        <ul>
          <li>Th·ªùi ti·∫øt: M√¥ t·∫£ + Nhi·ªát ƒë·ªô + ƒê·ªô ·∫©m</li>
          <li>PV Tips: Tr·∫°ng th√°i theo c√¥ng su·∫•t</li>
          <li>Weather Tips: N·∫Øng/M√¢y/M∆∞a/UV</li>
          <li>Fun Messages: Random greeting</li>
          <li>Tr·∫°ng th√°i ƒë·∫ßy ƒë·ªß: PV, Pin, Load, Grid</li>
        </ul>
      </div>
      <div class="feature-card">
        <h3>‚ö° C·∫£nh b√°o ƒêi·ªán (G·ªçn)</h3>
        <ul>
          <li>M·∫•t ƒëi·ªán: Pin, PV, T·∫£i</li>
          <li>C√≥ ƒëi·ªán l·∫°i: Grid, Pin, Th·ªùi gian m·∫•t</li>
          <li>Pin y·∫øu: Pin, PV, Grid</li>
          <li>H·∫øt PV: PV, Pin, Grid</li>
        </ul>
      </div>
    </div>
    
    <div class="copy-section">
      <div class="copy-header">
        <h2>üì¶ Full Code (1583 lines) - Click ƒë·ªÉ Copy</h2>
        <button class="copy-btn" onclick="copyCode()">üìã Copy Full Code</button>
      </div>
      <div class="code-container">
        <pre id="code-content">// Loading...</pre>
      </div>
    </div>
    
    <div class="info-section">
      <div class="info-card">
        <h3>üìù H∆∞·ªõng d·∫´n Deploy</h3>
        <ol>
          <li>Click <strong>"Copy Full Code"</strong> ·ªü tr√™n</li>
          <li>V√†o <strong>Cloudflare Dashboard</strong> ‚Üí Workers</li>
          <li>Ch·ªçn <code>lightearth-telegram-bot</code></li>
          <li>Click <strong>Quick Edit</strong></li>
          <li>X√≥a code c≈©, <strong>Paste code m·ªõi</strong></li>
          <li>Click <strong>Save and Deploy</strong></li>
          <li>Test: G·ªçi <code>/health</code> ‚Üí version "2.7"</li>
        </ol>
      </div>
      <div class="info-card">
        <h3>‚öôÔ∏è Environment Variables</h3>
        <ol>
          <li><code>BOT_TOKEN</code> - Telegram Bot Token</li>
          <li><code>PI_URL</code> - Home Assistant URL</li>
          <li><code>PI_TOKEN</code> - HA Long-lived Token</li>
          <li><code>BOT_KV</code> - KV Namespace binding</li>
        </ol>
        <p style="margin-top:10px;font-size:11px;color:#94a3b8">
          ‚ö†Ô∏è Token trong code l√† placeholder.<br>
          N√™n set qua Environment Variables.
        </p>
      </div>
    </div>
    
    <div class="info-card" style="margin-top:15px">
      <h3>üì± Sample Notifications v2.7</h3>
      <div class="sample-notifs">
üîãüíö *PIN ƒê·∫¶Y*
üì± `P250802210`

Pin: *97%* (ng∆∞·ª°ng: 95%)

üïê 04/01/2026 16:30:00
      </div>
      <div class="sample-notifs" style="margin-top:10px">
‚òÄÔ∏è *BU·ªîI S√ÅNG NƒÇNG ƒê·ªòNG*
PV ƒëang l√†m vi·ªác chƒÉm ch·ªâ, nƒÉng l∆∞·ª£ng ƒëang t√≠ch l≈©y!

üì± *P250802210*
‚òÄÔ∏è PV: *850W*
üíö Pin: *92%* üí™ Si√™u ƒë·∫ßy!
üè† Load: *320W*
‚ö° Grid: *0W* üü¢

üå§Ô∏è *Th·ªùi ti·∫øt TP. Ho Chi Minh:*
‚òÄÔ∏è Tr·ªùi quang
üå°Ô∏è 32¬∞C | üíß 65% | üí® 12 km/h

‚òÄÔ∏è _Tr·ªùi n·∫Øng ƒë·∫πp, PV s·∫Ω "bung l·ª•a" h√¥m nay!_

‚ö° _PV ƒëang ho·∫°t ƒë·ªông m·∫°nh m·∫Ω!_

üïê 04/01/2026 10:00:00
      </div>
    </div>
    
    <div class="footer">
      <p>LightEarth Bot v2.7 ‚Ä¢ Compact Notifications + Detailed Hourly ‚Ä¢ 04/01/2026</p>
      <p>KV Keys: devices_data, device_states, threshold_alerts, notification_flags</p>
    </div>
  </div>
  
  <script>
    const fullCode = `// LightEarth Telegram Bot - Cloudflare Worker with KV Storage
// Version: 2.7 - COMPACT + DETAILED HOURLY
//
// FEATURES:
// - üìã Th√¥ng b√°o ng∆∞·ª°ng g·ªçn g√†ng: 1 d√≤ng m·ªói ch·ªâ s·ªë
// - ‚è∞ B√°o c√°o m·ªói gi·ªù chi ti·∫øt v·ªõi th·ªùi ti·∫øt + tips
// - üîå Voltage s·ªë th·∫≠p ph√¢n: 50.5V thay v√¨ l√†m tr√≤n 51V
// - üî¢ H·ªó tr·ª£ d·∫•u ph·∫©y: nh·∫≠p 50,5 = 50.5
// - üìä Hi·ªÉn th·ªã ch√≠nh x√°c trong m·ªçi th√¥ng b√°o
// - üîã Battery Voltage Alerts: batteryVoltHigh v√† batteryVoltLow
// - üîî Alert Once: ch·ªâ b√°o 1 l·∫ßn/ng√†y/ng∆∞·ª°ng
// - üîó Ultra Short Deep Link: ‚â§64 chars
// - üéâ Fun Messages + Serious Alerts
// - ‚ö° Weather Cache per cron run
// - üì¶ Batch KV operations
//
// DEPLOYMENT:
// 1. Environment Variables: PI_URL, PI_TOKEN, BOT_TOKEN
// 2. KV Namespace Binding: BOT_KV
// 3. Cron Trigger: */5 * * * *
//
// SECURITY: BOT_TOKEN should be set as environment variable

// ============================================
// üîë TOKEN & API CONFIGURATION
// ============================================
// IMPORTANT: Replace YOUR_BOT_TOKEN_HERE with actual token in Cloudflare Dashboard
// Or set BOT_TOKEN as environment variable (recommended for security)
const BOT_TOKEN = typeof env !== 'undefined' && env.BOT_TOKEN ? env.BOT_TOKEN : 'YOUR_BOT_TOKEN_HERE';
const TELEGRAM_API = 'https://api.telegram.org/bot' + BOT_TOKEN;

// ============================================
// üåê CORS CONFIGURATION
// ============================================
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With, X-API-Key',
  'Access-Control-Max-Age': '86400'
};

function corsResponse(body, options = {}) {
  const headers = { ...CORS_HEADERS, ...(options.headers || {}) };
  return new Response(body, { ...options, headers });
}

function jsonResponse(data, status = 200) {
  return corsResponse(JSON.stringify(data, null, 2), {
    status, headers: { 'Content-Type': 'application/json' }
  });
}

// ============================================
// üì¶ KV STORAGE CONFIGURATION
// ============================================
const KV_KEYS = { 
  DEVICES: 'devices_data', 
  DEVICE_STATES: 'device_states',
  HA_CACHE: 'ha_cache',
  THRESHOLD_ALERTS: 'threshold_alerts',
  NOTIFICATION_FLAGS: 'notification_flags'
};

// Cache TTLs
const HA_CACHE_TTL = 21600;      // 6 hours
const WEATHER_CACHE_TTL = 3600;  // 1 hour

// ============================================
// ‚öôÔ∏è DEFAULT CONFIGURATIONS
// ============================================
const DEFAULT_THRESHOLDS = {
  batteryFull: 100,
  batteryLow: 20,
  pvDaily: 0,
  gridUsage: 0,
  loadDaily: 0,
  batteryVoltHigh: 0,  // 0 = T·∫ÆT, VD: 55V
  batteryVoltLow: 0    // 0 = T·∫ÆT, VD: 45V
};

const DEFAULT_DEVICES_DATA = [];

// ============================================
// üíæ KV STORAGE FUNCTIONS - OPTIMIZED BATCH
// ============================================
async function loadDevicesData(env) {
  if (!env.BOT_KV) return [...DEFAULT_DEVICES_DATA];
  try {
    const data = await env.BOT_KV.get(KV_KEYS.DEVICES, { type: 'json' });
    if (data && Array.isArray(data)) {
      data.forEach(d => { if (!d.thresholds) d.thresholds = { ...DEFAULT_THRESHOLDS }; });
      return data;
    }
    return [...DEFAULT_DEVICES_DATA];
  } catch (e) { return [...DEFAULT_DEVICES_DATA]; }
}

async function saveDevicesData(env, data) {
  if (!env.BOT_KV) return false;
  try { await env.BOT_KV.put(KV_KEYS.DEVICES, JSON.stringify(data)); return true; } catch (e) { return false; }
}

async function loadDeviceStates(env) {
  if (!env.BOT_KV) return {};
  try { return (await env.BOT_KV.get(KV_KEYS.DEVICE_STATES, { type: 'json' })) || {}; } catch (e) { return {}; }
}

async function saveDeviceStates(env, states) {
  if (!env.BOT_KV) return false;
  try { await env.BOT_KV.put(KV_KEYS.DEVICE_STATES, JSON.stringify(states)); return true; } catch (e) { return false; }
}

// ============================================
// üéØ THRESHOLD ALERT MANAGEMENT - BATCH OPTIMIZED
// ============================================
async function loadAllThresholdAlerts(env) {
  if (!env.BOT_KV) return {};
  try { return (await env.BOT_KV.get(KV_KEYS.THRESHOLD_ALERTS, { type: 'json' })) || {}; } catch (e) { return {}; }
}

async function saveAllThresholdAlerts(env, alerts) {
  if (!env.BOT_KV) return false;
  try { await env.BOT_KV.put(KV_KEYS.THRESHOLD_ALERTS, JSON.stringify(alerts)); return true; } catch (e) { return false; }
}

function getThresholdAlertKey(alerts, type, chatId, deviceId) {
  const key = \`\${type}_\${chatId}_\${deviceId}\`;
  return alerts[key] || null;
}

function setThresholdAlertKey(alerts, type, chatId, deviceId, value) {
  const key = \`\${type}_\${chatId}_\${deviceId}\`;
  alerts[key] = String(value);
}

function clearThresholdAlertKey(alerts, type, chatId, deviceId) {
  const key = \`\${type}_\${chatId}_\${deviceId}\`;
  delete alerts[key];
}

function clearAllThresholdAlertsForDevice(alerts, chatId, deviceId) {
  const types = ['full', 'low', 'pv', 'grid', 'load', 'bvhigh', 'bvlow'];
  types.forEach(type => {
    const key = \`\${type}_\${chatId}_\${deviceId}\`;
    delete alerts[key];
  });
}

// ============================================
// üö© NOTIFICATION FLAGS - BATCH OPTIMIZED
// ============================================
async function loadNotificationFlags(env) {
  if (!env.BOT_KV) return {};
  try { return (await env.BOT_KV.get(KV_KEYS.NOTIFICATION_FLAGS, { type: 'json' })) || {}; } catch (e) { return {}; }
}

async function saveNotificationFlags(env, flags) {
  if (!env.BOT_KV) return false;
  try { await env.BOT_KV.put(KV_KEYS.NOTIFICATION_FLAGS, JSON.stringify(flags)); return true; } catch (e) { return false; }
}

// In-memory user conversation states
const userStates = new Map();

// In-memory weather cache (per cron run)
let weatherCache = {};
function resetWeatherCache() { weatherCache = {}; }


// ============================================
// üó∫Ô∏è VIETNAM CITIES DATABASE
// ============================================
const VIETNAM_CITIES = {
  "TP. Ho Chi Minh": { lat: 10.8231, lon: 106.6297, region: "Mien Nam" },
  "Ba Ria - Vung Tau": { lat: 10.4114, lon: 107.1362, region: "Mien Nam" },
  "Binh Duong": { lat: 11.0753, lon: 106.6189, region: "Mien Nam" },
  "Binh Phuoc": { lat: 11.7512, lon: 106.7235, region: "Mien Nam" },
  "Dong Nai": { lat: 10.9574, lon: 106.8426, region: "Mien Nam" },
  "Tay Ninh": { lat: 11.3555, lon: 106.1099, region: "Mien Nam" },
  "Long An": { lat: 10.6956, lon: 106.2431, region: "Mien Nam" },
  "Tien Giang": { lat: 10.4493, lon: 106.3420, region: "Mien Nam" },
  "Ben Tre": { lat: 10.2433, lon: 106.3752, region: "Mien Nam" },
  "Vinh Long": { lat: 10.2537, lon: 105.9722, region: "Mien Nam" },
  "Tra Vinh": { lat: 9.8127, lon: 106.2993, region: "Mien Nam" },
  "Dong Thap": { lat: 10.4937, lon: 105.6882, region: "Mien Nam" },
  "An Giang": { lat: 10.5216, lon: 105.1259, region: "Mien Nam" },
  "Kien Giang": { lat: 10.0125, lon: 105.0809, region: "Mien Nam" },
  "Can Tho": { lat: 10.0452, lon: 105.7469, region: "Mien Nam" },
  "Hau Giang": { lat: 9.7579, lon: 105.6413, region: "Mien Nam" },
  "Soc Trang": { lat: 9.6037, lon: 105.9800, region: "Mien Nam" },
  "Bac Lieu": { lat: 9.2940, lon: 105.7216, region: "Mien Nam" },
  "Ca Mau": { lat: 9.1769, lon: 105.1524, region: "Mien Nam" },
  "Da Nang": { lat: 16.0544, lon: 108.2022, region: "Mien Trung" },
  "Thua Thien Hue": { lat: 16.4637, lon: 107.5909, region: "Mien Trung" },
  "Quang Nam": { lat: 15.5394, lon: 108.0191, region: "Mien Trung" },
  "Quang Ngai": { lat: 15.1214, lon: 108.8044, region: "Mien Trung" },
  "Binh Dinh": { lat: 13.7765, lon: 109.2237, region: "Mien Trung" },
  "Phu Yen": { lat: 13.0882, lon: 109.0929, region: "Mien Trung" },
  "Khanh Hoa": { lat: 12.2388, lon: 109.1967, region: "Mien Trung" },
  "Ninh Thuan": { lat: 11.5752, lon: 108.9890, region: "Mien Trung" },
  "Binh Thuan": { lat: 10.9289, lon: 108.1021, region: "Mien Trung" },
  "Quang Binh": { lat: 17.4656, lon: 106.6222, region: "Mien Trung" },
  "Quang Tri": { lat: 16.7504, lon: 107.1856, region: "Mien Trung" },
  "Ha Tinh": { lat: 18.3559, lon: 105.8877, region: "Mien Trung" },
  "Nghe An": { lat: 18.6737, lon: 105.6922, region: "Mien Trung" },
  "Thanh Hoa": { lat: 19.8067, lon: 105.7852, region: "Mien Trung" },
  "Kon Tum": { lat: 14.3545, lon: 108.0005, region: "Tay Nguyen" },
  "Gia Lai": { lat: 13.9833, lon: 108.0000, region: "Tay Nguyen" },
  "Dak Lak": { lat: 12.6800, lon: 108.0378, region: "Tay Nguyen" },
  "Dak Nong": { lat: 12.0033, lon: 107.6876, region: "Tay Nguyen" },
  "Lam Dong": { lat: 11.9404, lon: 108.4583, region: "Tay Nguyen" },
  "Ha Noi": { lat: 21.0285, lon: 105.8542, region: "Mien Bac" },
  "Hai Phong": { lat: 20.8449, lon: 106.6881, region: "Mien Bac" },
  "Quang Ninh": { lat: 21.0064, lon: 107.2925, region: "Mien Bac" },
  "Bac Giang": { lat: 21.2819, lon: 106.1975, region: "Mien Bac" },
  "Bac Ninh": { lat: 21.1861, lon: 106.0763, region: "Mien Bac" },
  "Hai Duong": { lat: 20.9373, lon: 106.3146, region: "Mien Bac" },
  "Hung Yen": { lat: 20.6464, lon: 106.0511, region: "Mien Bac" },
  "Thai Binh": { lat: 20.4463, lon: 106.3365, region: "Mien Bac" },
  "Nam Dinh": { lat: 20.4388, lon: 106.1621, region: "Mien Bac" },
  "Ninh Binh": { lat: 20.2506, lon: 105.9745, region: "Mien Bac" },
  "Ha Nam": { lat: 20.5835, lon: 105.9230, region: "Mien Bac" },
  "Vinh Phuc": { lat: 21.3609, lon: 105.5474, region: "Mien Bac" },
  "Phu Tho": { lat: 21.3227, lon: 105.2280, region: "Mien Bac" },
  "Thai Nguyen": { lat: 21.5942, lon: 105.8482, region: "Mien Bac" },
  "Bac Kan": { lat: 22.1470, lon: 105.8348, region: "Mien Bac" },
  "Cao Bang": { lat: 22.6663, lon: 106.2522, region: "Mien Bac" },
  "Lang Son": { lat: 21.8537, lon: 106.7615, region: "Mien Bac" },
  "Tuyen Quang": { lat: 21.8233, lon: 105.2180, region: "Mien Bac" },
  "Ha Giang": { lat: 22.8333, lon: 104.9833, region: "Mien Bac" },
  "Yen Bai": { lat: 21.7168, lon: 104.8986, region: "Mien Bac" },
  "Lao Cai": { lat: 22.4856, lon: 103.9707, region: "Mien Bac" },
  "Lai Chau": { lat: 22.3864, lon: 103.4703, region: "Mien Bac" },
  "Dien Bien": { lat: 21.3860, lon: 103.0230, region: "Mien Bac" },
  "Son La": { lat: 21.3256, lon: 103.9188, region: "Mien Bac" },
  "Hoa Binh": { lat: 20.8171, lon: 105.3376, region: "Mien Bac" }
};

// ============================================
// üìç SHORT LOCATION CODES
// ============================================
const LOCATION_CODES = {
  'hcm': 'TP. Ho Chi Minh', 'hn': 'Ha Noi', 'dng': 'Da Nang', 'ct': 'Can Tho',
  'bd': 'Binh Duong', 'tn': 'Tay Ninh', 'dn': 'Dong Nai', 'dl': 'Lam Dong',
  'la': 'Long An', 'tg': 'Tien Giang', 'bt': 'Ben Tre', 'vl': 'Vinh Long',
  'tv': 'Tra Vinh', 'dt': 'Dong Thap', 'ag': 'An Giang', 'kg': 'Kien Giang',
  'hg': 'Hau Giang', 'st': 'Soc Trang', 'bl': 'Bac Lieu', 'cm': 'Ca Mau',
  'brvt': 'Ba Ria - Vung Tau', 'bp': 'Binh Phuoc', 'tth': 'Thua Thien Hue',
  'qna': 'Quang Nam', 'qng': 'Quang Ngai', 'bdi': 'Binh Dinh', 'py': 'Phu Yen',
  'kh': 'Khanh Hoa', 'nt': 'Ninh Thuan', 'bth': 'Binh Thuan', 'qb': 'Quang Binh',
  'qt': 'Quang Tri', 'hti': 'Ha Tinh', 'na': 'Nghe An', 'th': 'Thanh Hoa',
  'kt': 'Kon Tum', 'gl': 'Gia Lai', 'dlk': 'Dak Lak', 'dno': 'Dak Nong',
  'hp': 'Hai Phong', 'qni': 'Quang Ninh', 'bg': 'Bac Giang', 'bn': 'Bac Ninh',
  'hdu': 'Hai Duong', 'hy': 'Hung Yen', 'tb': 'Thai Binh', 'nd': 'Nam Dinh',
  'nb': 'Ninh Binh', 'hna': 'Ha Nam', 'vp': 'Vinh Phuc', 'pt': 'Phu Tho',
  'tnu': 'Thai Nguyen', 'bk': 'Bac Kan', 'cb': 'Cao Bang', 'ls': 'Lang Son',
  'tqu': 'Tuyen Quang', 'hgi': 'Ha Giang', 'yb': 'Yen Bai', 'lc': 'Lao Cai',
  'lch': 'Lai Chau', 'db': 'Dien Bien', 'sla': 'Son La', 'hbi': 'Hoa Binh'
};

function decodeLocationCode(code) {
  if (!code) return "TP. Ho Chi Minh";
  const lowerCode = code.toLowerCase();
  if (LOCATION_CODES[lowerCode]) return LOCATION_CODES[lowerCode];
  for (const [short, full] of Object.entries(LOCATION_CODES)) {
    if (lowerCode.includes(short) || short.includes(lowerCode)) return full;
  }
  const decoded = code.replace(/_/g, ' ').replace(/\\s+/g, ' ').trim();
  for (const city of Object.keys(VIETNAM_CITIES)) {
    if (city.toLowerCase().replace(/[^a-z0-9]/g, '') === decoded.toLowerCase().replace(/[^a-z0-9]/g, '')) return city;
  }
  return "TP. Ho Chi Minh";
}

function encodeLocationCode(cityName) {
  if (!cityName) return 'hcm';
  for (const [code, name] of Object.entries(LOCATION_CODES)) {
    if (name === cityName) return code;
  }
  return 'hcm';
}

// ============================================
// üî¢ NOTIFICATION BITS PARSING
// ============================================
function parseNotificationBits(bits) {
  const defaultNotifs = { morningGreeting: true, powerOutage: true, powerRestored: true, lowBattery: true, pvEnded: true, hourlyStatus: false };
  if (!bits || bits.length !== 6) return defaultNotifs;
  return {
    morningGreeting: bits[0] === '1',
    powerOutage: bits[1] === '1',
    powerRestored: bits[2] === '1',
    lowBattery: bits[3] === '1',
    pvEnded: bits[4] === '1',
    hourlyStatus: bits[5] === '1'
  };
}

function encodeNotificationBits(notifications) {
  if (!notifications) return '111110';
  return [
    notifications.morningGreeting ? '1' : '0',
    notifications.powerOutage ? '1' : '0',
    notifications.powerRestored ? '1' : '0',
    notifications.lowBattery ? '1' : '0',
    notifications.pvEnded ? '1' : '0',
    notifications.hourlyStatus ? '1' : '0'
  ].join('');
}

// ============================================
// üïê TIME HELPERS (Vietnam Timezone)
// ============================================
function getVietnamTime() { return new Date().toLocaleString('en-GB', { timeZone: 'Asia/Ho_Chi_Minh', hour12: false }).replace(',', ''); }
function getVietnamHour() { return new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Ho_Chi_Minh' })).getHours(); }
function getVietnamDate() { return new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Ho_Chi_Minh' })).toISOString().split('T')[0]; }

// ============================================
// üé® ICONS & STATUS HELPERS
// ============================================
function getBatteryIcon(soc) { 
  if (soc <= 5) return 'üî¥'; 
  if (soc <= 20) return 'üü†'; 
  if (soc <= 50) return 'üü°'; 
  if (soc <= 80) return 'üü¢';
  return 'üíö'; 
}

function getGridIcon(hasGrid) { return hasGrid ? 'üü¢' : 'üî¥'; }

function getWeatherIcon(code) {
  const icons = { 0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è', 45: 'üå´Ô∏è', 48: 'üå´Ô∏è', 51: 'üåßÔ∏è', 53: 'üåßÔ∏è', 55: 'üåßÔ∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è', 80: 'üå¶Ô∏è', 81: 'üå¶Ô∏è', 82: 'üå¶Ô∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è' };
  return icons[code] || 'üå§Ô∏è';
}

function getBatteryFunStatus(soc) {
  if (soc >= 90) return 'üí™ Si√™u ƒë·∫ßy!';
  if (soc >= 80) return 'üíö Tuy·ªát v·ªùi!';
  if (soc >= 60) return 'üü¢ T·ªët l·∫Øm!';
  if (soc >= 40) return 'üü° OK';
  if (soc >= 20) return 'üü† H∆°i th·∫•p';
  return 'üî¥ C·∫ßn s·∫°c!';
}

function getRandomItem(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

// ============================================
// üéâ FUN & FRIENDLY MESSAGE TEMPLATES
// ============================================
const MORNING_GREETINGS = [
  "üåÖ *Ch√†o bu·ªïi s√°ng!*",
  "‚òÄÔ∏è *Good morning!*",
  "üåû *Ch√†o ng√†y m·ªõi!*",
  "üåÑ *Ohayo!*",
  "‚ú® *Rise & Shine!*",
  "üîÜ *Xin ch√†o!*",
  "üåª *Hello Sunshine!*",
  "‚≠ê *Ch√†o bu·ªïi s√°ng!*"
];

const HOURLY_MESSAGES = {
  early_morning: [
    { emoji: 'üåÖ', label: 'S√ÅNG S·ªöM TINH M∆†', greeting: 'M·∫∑t tr·ªùi v·ª´a l√≥ d·∫°ng, PV ƒëang "kh·ªüi ƒë·ªông"!' },
    { emoji: 'üå§Ô∏è', label: 'B√åNH MINH ƒê·∫∏P', greeting: 'Ng√†y m·ªõi b·∫Øt ƒë·∫ßu, nƒÉng l∆∞·ª£ng xanh s·∫µn s√†ng!' },
    { emoji: '‚òÄÔ∏è', label: 'EARLY BIRD', greeting: 'Ai d·∫≠y s·ªõm c√≥... n·∫Øng! PV s·∫Øp ho·∫°t ƒë·ªông!' }
  ],
  morning: [
    { emoji: '‚òÄÔ∏è', label: 'BU·ªîI S√ÅNG NƒÇNG ƒê·ªòNG', greeting: 'PV ƒëang l√†m vi·ªác chƒÉm ch·ªâ, nƒÉng l∆∞·ª£ng ƒëang t√≠ch l≈©y!' },
    { emoji: 'üåû', label: 'MORNING REPORT', greeting: 'M·ªçi th·ª© ƒë·ªÅu ·ªïn, h·ªá th·ªëng ch·∫°y ngon l√†nh!' },
    { emoji: '‚ú®', label: 'S√ÅNG NAY TUY·ªÜT V·ªúI', greeting: 'T·∫•m pin ƒëang "h·ª©ng n·∫Øng" c·ª±c t·ªët!' }
  ],
  noon: [
    { emoji: 'üåû', label: 'GI·ªÆA TR∆ØA R·ª∞C R·ª†', greeting: 'ƒê·ªânh cao nƒÉng l∆∞·ª£ng m·∫∑t tr·ªùi!' },
    { emoji: 'üî•', label: 'PEAK HOUR', greeting: 'PV ƒëang "ch√°y" h·∫øt c√¥ng su·∫•t!' },
    { emoji: '‚òÄÔ∏è', label: 'NOONTIME REPORT', greeting: 'M·∫∑t tr·ªùi ·ªü ƒë·ªânh, PV ·ªü max!' }
  ],
  afternoon: [
    { emoji: 'üå§Ô∏è', label: 'CHI·ªÄU NAY TH·∫æ N√ÄO?', greeting: 'H·ªá th·ªëng v·∫´n ƒëang l√†m vi·ªác hi·ªáu qu·∫£!' },
    { emoji: '‚òÄÔ∏è', label: 'AFTERNOON UPDATE', greeting: 'NƒÉng l∆∞·ª£ng v·∫´n ƒëang ƒë∆∞·ª£c thu ho·∫°ch!' },
    { emoji: '‚ú®', label: 'BU·ªîI CHI·ªÄU D·ªÑ CH·ªäU', greeting: 'PV ti·∫øp t·ª•c ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh!' }
  ],
  late_afternoon: [
    { emoji: 'üåá', label: 'CHI·ªÄU MU·ªòN R·ªíI', greeting: 'PV ƒëang ho√†n th√†nh ca l√†m vi·ªác!' },
    { emoji: 'üåÜ', label: 'SUNSET APPROACHING', greeting: 'Chu·∫©n b·ªã chuy·ªÉn sang ch·∫ø ƒë·ªô pin nh√©!' },
    { emoji: '‚ú®', label: 'HO√ÄNG H√îN ƒê·∫∏P QU√Å', greeting: 'Ng√†y l√†m vi·ªác c·ªßa PV s·∫Øp k·∫øt th√∫c!' }
  ],
  evening: [
    { emoji: 'üåô', label: 'T·ªêI R·ªíI, LUMENTREE-ER!', greeting: 'Pin ƒë√£ s·∫µn s√†ng thay ca cho PV!' },
    { emoji: 'üåÉ', label: 'EVENING REPORT', greeting: 'H·ªá th·ªëng ƒëang ch·∫°y b·∫±ng pin t√≠ch tr·ªØ!' },
    { emoji: '‚ú®', label: 'CH√öC BU·ªîI T·ªêI VUI V·∫∫', greeting: 'Lumentree v·∫´n ƒë·ªìng h√†nh c√πng b·∫°n!' }
  ]
};

// Weather tips
const SUNNY_TIPS = [
  "‚òÄÔ∏è _Tr·ªùi n·∫Øng ƒë·∫πp, PV s·∫Ω \\"bung l·ª•a\\" h√¥m nay!_",
  "üåû _Ng√†y n·∫Øng v√†ng, nƒÉng l∆∞·ª£ng tr√†n ng·∫≠p!_",
  "üîÜ _Th·ªùi ti·∫øt l√Ω t∆∞·ªüng ƒë·ªÉ \\"h√∫t\\" nƒÉng l∆∞·ª£ng!_",
  "‚ö° _N·∫Øng to = PV max! Ng√†y ho√†n h·∫£o ƒë√¢y r·ªìi!_"
];

const CLOUDY_TIPS = [
  "‚õÖ _M√¢y h∆°i nhi·ªÅu, PV v·∫´n l√†m vi·ªác t·ªët!_",
  "üå§Ô∏è _C√≥ m√¢y nh∆∞ng ƒë·ª´ng lo, PV v·∫´n ho·∫°t ƒë·ªông!_",
  "‚òÅÔ∏è _Tr·ªùi r√¢m m√°t, PV ngh·ªâ ng∆°i nh·∫π nh√†ng~_"
];

const RAINY_TIPS = [
  "üåßÔ∏è _Tr·ªùi m∆∞a r·ªìi, PV t·∫°m ngh·ªâ, pin l√™n s√†n!_",
  "‚òî _M∆∞a th√¨ m∆∞a, Lumentree v·∫´n lo ƒë∆∞·ª£c!_",
  "üå¶Ô∏è _M∆∞a cho c√¢y t∆∞∆°i, pin v·∫´n ƒë·∫ßy!_"
];

const UV_HIGH_TIPS = [
  "üî• _UV cao! PV s·∫Ω ho·∫°t ƒë·ªông c·ª±c m·∫°nh!_",
  "‚òÄÔ∏è _Ch·ªâ s·ªë UV cao = thu ho·∫°ch nƒÉng l∆∞·ª£ng t·ªëi ƒëa!_",
  "‚ö° _UV index cao, ng√†y v√†ng ƒë·ªÉ s·∫°c pin!_"
];

function getWeatherTip(weather, pvPower) {
  if (!weather) return '';
  if (weather.rainChance > 60) return getRandomItem(RAINY_TIPS);
  if (weather.uvIndex >= 8) return getRandomItem(UV_HIGH_TIPS);
  if (weather.uvIndex >= 5 || pvPower > 500) return getRandomItem(SUNNY_TIPS);
  if (weather.description?.toLowerCase().includes('m√¢y') || weather.description?.toLowerCase().includes('cloud')) return getRandomItem(CLOUDY_TIPS);
  return getRandomItem(SUNNY_TIPS);
}

function getHourlyTemplate(vnHour) {
  if (vnHour >= 5 && vnHour < 8) return getRandomItem(HOURLY_MESSAGES.early_morning);
  if (vnHour >= 8 && vnHour < 12) return getRandomItem(HOURLY_MESSAGES.morning);
  if (vnHour >= 12 && vnHour < 14) return getRandomItem(HOURLY_MESSAGES.noon);
  if (vnHour >= 14 && vnHour < 17) return getRandomItem(HOURLY_MESSAGES.afternoon);
  if (vnHour >= 17 && vnHour < 19) return getRandomItem(HOURLY_MESSAGES.late_afternoon);
  return getRandomItem(HOURLY_MESSAGES.evening);
}


// ============================================
// üì± DEVICE MANAGEMENT FUNCTIONS
// ============================================
function getUserDevices(devicesData, chatId) { 
  return devicesData.filter(d => d.chatId === chatId); 
}

async function addDeviceWithSettings(env, devicesData, chatId, deviceId, notifications, location, thresholds, alerts) {
  const upperDeviceId = deviceId.toUpperCase();
  const existingIndex = devicesData.findIndex(d => d.chatId === chatId && d.deviceId.toUpperCase() === upperDeviceId);
  
  const deviceData = {
    deviceId: upperDeviceId,
    chatId,
    addedAt: getVietnamTime(),
    location: location || "TP. Ho Chi Minh",
    notifications: notifications || { morningGreeting: true, powerOutage: true, powerRestored: true, lowBattery: true, pvEnded: true, hourlyStatus: false },
    thresholds: thresholds || { ...DEFAULT_THRESHOLDS }
  };
  
  if (existingIndex >= 0) {
    devicesData[existingIndex] = { ...devicesData[existingIndex], ...deviceData, addedAt: devicesData[existingIndex].addedAt };
    if (alerts) clearAllThresholdAlertsForDevice(alerts, chatId, upperDeviceId);
  } else {
    devicesData.push(deviceData);
  }
  
  await saveDevicesData(env, devicesData);
  return { success: true, isNew: existingIndex < 0, devicesData };
}

async function addDevice(env, devicesData, chatId, deviceId) {
  const exists = devicesData.some(d => d.chatId === chatId && d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (exists) return { success: false, devicesData };
  devicesData.push({ 
    deviceId: deviceId.toUpperCase(), 
    chatId, 
    addedAt: getVietnamTime(), 
    location: "TP. Ho Chi Minh", 
    notifications: { morningGreeting: true, powerOutage: true, powerRestored: true, lowBattery: true, pvEnded: true, hourlyStatus: false },
    thresholds: { ...DEFAULT_THRESHOLDS }
  });
  await saveDevicesData(env, devicesData);
  return { success: true, devicesData };
}

async function removeDevice(env, devicesData, chatId, deviceId, alerts) {
  const index = devicesData.findIndex(d => d.chatId === chatId && d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (index === -1) return { success: false, devicesData };
  if (alerts) clearAllThresholdAlertsForDevice(alerts, chatId, deviceId.toUpperCase());
  devicesData.splice(index, 1);
  await saveDevicesData(env, devicesData);
  return { success: true, devicesData };
}

async function updateDeviceSettings(env, devicesData, chatId, deviceId, settingNum) {
  const device = devicesData.find(d => d.chatId === chatId && d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (!device || !device.notifications) return null;
  const settingMap = { 1: 'morningGreeting', 2: 'powerOutage', 3: 'powerRestored', 4: 'lowBattery', 5: 'pvEnded', 6: 'hourlyStatus' };
  const setting = settingMap[settingNum];
  if (!setting) return null;
  device.notifications[setting] = !device.notifications[setting];
  await saveDevicesData(env, devicesData);
  return { setting, newValue: device.notifications[setting] };
}

async function updateSingleDeviceLocation(env, devicesData, chatId, deviceId, location) {
  const device = devicesData.find(d => d.chatId === chatId && d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (!device) return false;
  device.location = location;
  await saveDevicesData(env, devicesData);
  return true;
}

async function updateDeviceThresholds(env, devicesData, chatId, deviceId, newThresholds, alerts) {
  const device = devicesData.find(d => d.chatId === chatId && d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (!device) return false;
  const oldThresholds = device.thresholds || { ...DEFAULT_THRESHOLDS };
  device.thresholds = { ...oldThresholds, ...newThresholds };
  if (alerts) clearAllThresholdAlertsForDevice(alerts, chatId, deviceId.toUpperCase());
  await saveDevicesData(env, devicesData);
  return true;
}


// ============================================
// üè† HOME ASSISTANT API - OPTIMIZED
// ============================================
async function fetchAllDevicesFromHA(env) {
  const PI_URL = env.PI_URL || env.HA_URL;
  const PI_TOKEN = env.PI_TOKEN || env.HA_TOKEN;
  if (!PI_URL || !PI_TOKEN) return [];
  
  try {
    const response = await fetch(\`\${PI_URL}/api/states\`, { 
      headers: { 'Authorization': \`Bearer \${PI_TOKEN}\`, 'Content-Type': 'application/json' } 
    });
    if (!response.ok) return [];
    
    const states = await response.json();
    const deviceIds = new Set();
    states.forEach(state => { 
      const match = state.entity_id.match(/^sensor\\.device_([a-z0-9]+)_/i); 
      if (match) deviceIds.add(match[1].toUpperCase()); 
    });
    
    const devices = [];
    for (const deviceId of deviceIds) {
      const devicePrefix = \`sensor.device_\${deviceId.toLowerCase()}_\`;
      const binaryPrefix = \`binary_sensor.device_\${deviceId.toLowerCase()}_\`;
      const deviceStates = states.filter(s => s.entity_id.startsWith(devicePrefix));
      const binaryStates = states.filter(s => s.entity_id.startsWith(binaryPrefix));
      
      const getValue = (suffix) => { 
        const entity = deviceStates.find(s => s.entity_id === \`\${devicePrefix}\${suffix}\`); 
        return entity?.state !== 'unavailable' && entity?.state !== 'unknown' ? entity?.state : null; 
      };
      const parseNum = (val) => val !== null ? parseFloat(val) : 0;
      
      const onlineEntity = binaryStates.find(s => s.entity_id.includes('_online_status'));
      const isOnline = onlineEntity?.state === 'on' || (getValue('pv_power') !== null);
      const gridPower = Math.round(parseNum(getValue('grid_power')));
      const acInputVoltage = parseNum(getValue('ac_input_voltage')) || parseNum(getValue('grid_voltage'));
      const hasGridPower = gridPower > 50 || acInputVoltage > 100;
      const gridToday = Math.round(parseNum(getValue('grid_today')) * 100) / 100;
      const batteryVoltage = Math.round(parseNum(getValue('battery_voltage')) * 10) / 10;
      
      devices.push({ 
        deviceId, isOnline, hasGridPower, 
        realtime: { 
          batterySoc: Math.round(parseNum(getValue('battery_soc'))), 
          pvPower: Math.round(parseNum(getValue('pv_power'))), 
          batteryPower: Math.round(parseNum(getValue('battery_power'))), 
          loadPower: Math.round(parseNum(getValue('total_load_power')) || parseNum(getValue('load_power'))), 
          gridPower, acInputVoltage, batteryVoltage,
          temperature: Math.round(parseNum(getValue('device_temperature')) * 10) / 10 
        }, 
        dailyEnergy: { 
          pvDay: Math.round(parseNum(getValue('pv_today')) * 100) / 100, 
          loadDay: Math.round((parseNum(getValue('total_load_today')) || parseNum(getValue('load_today'))) * 100) / 100,
          gridDay: gridToday
        } 
      });
    }
    return devices;
  } catch (e) { return []; }
}

// Filter HA devices to only registered ones - OPTIMIZATION
function filterRegisteredDevices(haDevices, devicesData) {
  const registeredIds = new Set(devicesData.map(d => d.deviceId.toUpperCase()));
  return haDevices.filter(d => registeredIds.has(d.deviceId.toUpperCase()));
}

// ============================================
// üå§Ô∏è WEATHER API - WITH CACHING
// ============================================
async function getWeather(location) {
  // Check cache first
  if (weatherCache[location]) {
    return weatherCache[location];
  }
  
  const city = VIETNAM_CITIES[location];
  if (!city) return null;
  
  try {
    const response = await fetch(\`https://api.open-meteo.com/v1/forecast?latitude=\${city.lat}&longitude=\${city.lon}&hourly=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,uv_index&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max,sunrise,sunset&timezone=Asia/Ho_Chi_Minh&forecast_days=1\`);
    if (response.ok) {
      const data = await response.json();
      const weatherCodes = { 0: 'Tr·ªùi quang', 1: '√çt m√¢y', 2: 'M√¢y m·ªôt ph·∫ßn', 3: 'Nhi·ªÅu m√¢y', 45: 'S∆∞∆°ng m√π', 48: 'S∆∞∆°ng m√π ƒë√¥ng', 51: 'M∆∞a ph√πn nh·∫π', 53: 'M∆∞a ph√πn', 55: 'M∆∞a ph√πn d√†y', 61: 'M∆∞a nh·∫π', 63: 'M∆∞a v·ª´a', 65: 'M∆∞a to', 80: 'M∆∞a r√†o nh·∫π', 81: 'M∆∞a r√†o', 82: 'M∆∞a r√†o to', 95: 'D√¥ng', 96: 'D√¥ng k√®m m∆∞a ƒë√°' };
      const vnHour = getVietnamHour();
      const currentTemp = data.hourly?.temperature_2m?.[vnHour] || data.daily.temperature_2m_max[0];
      const sunrise = data.daily?.sunrise?.[0]?.split('T')[1]?.slice(0, 5) || '06:00';
      const sunset = data.daily?.sunset?.[0]?.split('T')[1]?.slice(0, 5) || '18:00';
      const hourlyWeatherCode = data.hourly?.weather_code?.[vnHour];
      const dailyCode = data.daily.weather_code[0];
      
      const weather = { 
        description: weatherCodes[dailyCode] || 'Kh√¥ng r√µ',
        currentDescription: weatherCodes[hourlyWeatherCode] || weatherCodes[dailyCode] || 'Kh√¥ng r√µ',
        icon: getWeatherIcon(hourlyWeatherCode || dailyCode),
        tempMax: data.daily.temperature_2m_max[0], 
        tempMin: data.daily.temperature_2m_min[0],
        currentTemp: Math.round(currentTemp),
        humidity: data.hourly?.relative_humidity_2m?.[vnHour] || 0,
        windSpeed: Math.round(data.hourly?.wind_speed_10m?.[vnHour] || 0),
        uvIndex: Math.round(data.hourly?.uv_index?.[vnHour] || 0),
        rainChance: data.daily.precipitation_probability_max[0] || 0,
        sunrise, sunset,
        source: 'open-meteo'
      };
      
      // Cache the result
      weatherCache[location] = weather;
      return weather;
    }
  } catch (e) { }
  
  // Fallback to wttr.in
  try {
    const cityQuery = location.replace(/\\s+/g, '+');
    const response = await fetch(\`https://wttr.in/\${cityQuery}?format=j1\`);
    if (response.ok) {
      const data = await response.json();
      const current = data.current_condition?.[0];
      const today = data.weather?.[0];
      const astronomy = today?.astronomy?.[0];
      
      if (current && today) {
        const weatherDesc = current.lang_vi?.[0]?.value || current.weatherDesc?.[0]?.value || 'Kh√¥ng r√µ';
        const code = parseInt(current.weatherCode) || 0;
        
        const weather = {
          description: weatherDesc,
          currentDescription: weatherDesc,
          icon: getWeatherIcon(code === 113 ? 0 : code === 116 ? 1 : code === 119 ? 3 : code >= 176 ? 61 : 2),
          tempMax: parseFloat(today.maxtempC) || 0,
          tempMin: parseFloat(today.mintempC) || 0,
          currentTemp: parseFloat(current.temp_C) || 0,
          humidity: parseFloat(current.humidity) || 0,
          windSpeed: parseFloat(current.windspeedKmph) || 0,
          uvIndex: parseFloat(current.uvIndex) || 0,
          rainChance: parseFloat(today.hourly?.[12]?.chanceofrain) || 0,
          sunrise: astronomy?.sunrise?.replace(/\\s*AM/i, '') || '06:00',
          sunset: astronomy?.sunset?.replace(/\\s*PM/i, '').replace(/^(\\d):/, '1\$1:') || '18:00',
          source: 'wttr.in'
        };
        
        // Cache the result
        weatherCache[location] = weather;
        return weather;
      }
    }
  } catch (e) { }
  
  return null;
}

// ============================================
// üì§ TELEGRAM API
// ============================================
async function sendTelegram(chatId, text, env) {
  const token = env?.BOT_TOKEN || BOT_TOKEN;
  const api = 'https://api.telegram.org/bot' + token;
  try { 
    const response = await fetch(api + '/sendMessage', { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify({ chat_id: chatId, text: text, parse_mode: 'Markdown' }) 
    }); 
    return (await response.json()).ok; 
  } catch (e) { return false; }
}


// ============================================
// üîî NOTIFICATION PROCESSING v2.6 - COMPACT FORMAT
// ============================================

async function processNotifications(env) {
  // Reset weather cache for this cron run
  resetWeatherCache();
  
  // Load all data in parallel - OPTIMIZATION
  const [devicesData, previousStates, thresholdAlerts, notificationFlags] = await Promise.all([
    loadDevicesData(env),
    loadDeviceStates(env),
    loadAllThresholdAlerts(env),
    loadNotificationFlags(env)
  ]);
  
  // Get unique device IDs from registered users
  const registeredDeviceIds = [...new Set(devicesData.map(d => d.deviceId.toUpperCase()))];
  if (registeredDeviceIds.length === 0) {
    return { sent: 0, checked: 0, haDevices: 0 };
  }
  
  // Fetch HA devices and filter to only registered ones - OPTIMIZATION
  const allHaDevices = await fetchAllDevicesFromHA(env);
  const haDevices = filterRegisteredDevices(allHaDevices, devicesData);
  
  const currentStates = {};
  const notifications = [];
  const vnHour = getVietnamHour();
  const vnDate = getVietnamDate();
  
  let alertsChanged = false;
  let flagsChanged = false;

  for (const userDevice of devicesData) {
    const deviceId = userDevice.deviceId.toUpperCase();
    const chatId = userDevice.chatId;
    const prefs = userDevice.notifications || {};
    const thresholds = userDevice.thresholds || { ...DEFAULT_THRESHOLDS };
    const stateKey = \`\${chatId}_\${deviceId}\`;
    const haDevice = haDevices.find(d => d.deviceId.toUpperCase() === deviceId);
    
    if (!haDevice) continue;
    
    const prevState = previousStates[stateKey] || {};
    const rt = haDevice.realtime;
    const de = haDevice.dailyEnergy;
    const currentState = { 
      hasGridPower: haDevice.hasGridPower, 
      batterySoc: rt.batterySoc, 
      pvPower: rt.pvPower, 
      isLowBattery: rt.batterySoc <= 20, 
      hasPV: rt.pvPower > 50, 
      lastUpdate: Date.now(), 
      powerOutageTime: prevState.powerOutageTime || null 
    };

    // ‚ö° M·∫§T ƒêI·ªÜN L∆Ø·ªöI - COMPACT v2.6
    if (prefs.powerOutage && prevState.hasGridPower === true && !currentState.hasGridPower) {
      currentState.powerOutageTime = Date.now();
      notifications.push({ 
        chatId, 
        message: \`‚ö°üî¥ *M·∫§T ƒêI·ªÜN*\\nüì± \\\`\${deviceId}\\\`\\n\\nPin: *\${rt.batterySoc}%*\\nPV: *\${rt.pvPower}W*\\nT·∫£i: *\${rt.loadPower}W*\\n\\nüïê \${getVietnamTime()}\` 
      });
    }

    // ‚úÖ C√ì ƒêI·ªÜN L·∫†I - COMPACT v2.6
    if (prefs.powerRestored && prevState.hasGridPower === false && currentState.hasGridPower) {
      let durationMsg = '';
      if (prevState.powerOutageTime) { 
        const mins = Math.floor((Date.now() - prevState.powerOutageTime) / 60000); 
        durationMsg = mins >= 60 ? \`\\nM·∫•t ƒëi·ªán: *\${Math.floor(mins/60)}h\${mins%60}p*\` : \`\\nM·∫•t ƒëi·ªán: *\${mins}p*\`; 
      }
      notifications.push({ 
        chatId, 
        message: \`‚úÖüü¢ *C√ì ƒêI·ªÜN L·∫†I*\\nüì± \\\`\${deviceId}\\\`\\n\\nGrid: *\${rt.gridPower}W*\\nPin: *\${rt.batterySoc}%*\${durationMsg}\\n\\nüïê \${getVietnamTime()}\` 
      });
      currentState.powerOutageTime = null;
    }

    // ü™´ PIN Y·∫æU - COMPACT v2.6
    if (prefs.lowBattery && !prevState.isLowBattery && currentState.isLowBattery) {
      notifications.push({ 
        chatId, 
        message: \`ü™´üî¥ *PIN Y·∫æU*\\nüì± \\\`\${deviceId}\\\`\\n\\nPin: *\${rt.batterySoc}%*\\nPV: *\${rt.pvPower}W*\\nGrid: *\${rt.gridPower}W* \${getGridIcon(haDevice.hasGridPower)}\\n\\nüïê \${getVietnamTime()}\` 
      });
    }

    // üåá K·∫æT TH√öC NG√ÄY N·∫ÆNG - COMPACT v2.6
    if (prefs.pvEnded && prevState.hasPV && !currentState.hasPV && vnHour >= 16 && vnHour <= 19) {
      notifications.push({ 
        chatId, 
        message: \`üåá *H·∫æT PV*\\nüì± \\\`\${deviceId}\\\`\\n\\nPV: *\${rt.pvPower}W*\\nPin: *\${rt.batterySoc}%*\\nGrid: *\${rt.gridPower}W* \${getGridIcon(haDevice.hasGridPower)}\\n\\nüïê \${getVietnamTime()}\` 
      });
    }

    // üåÖ CH√ÄO BU·ªîI S√ÅNG - COMPACT v2.6
    if (prefs.morningGreeting && vnHour >= 6 && vnHour < 7) {
      const morningKey = \`morning_\${chatId}_\${deviceId}\`;
      if (notificationFlags[morningKey] !== vnDate) {
        const weather = await getWeather(userDevice.location || 'TP. Ho Chi Minh');
        const greeting = getRandomItem(MORNING_GREETINGS);
        
        let weatherInfo = '';
        if (weather) {
          weatherInfo = \`\\n\\n\${weather.icon} \${weather.currentTemp}¬∞C | \${weather.humidity}% | \${weather.rainChance}% m∆∞a\`;
        }
        
        notifications.push({ 
          chatId, 
          message: \`\${greeting}\\nüì± \\\`\${deviceId}\\\`\\n\\nPin: *\${rt.batterySoc}%*\\nPV: *\${rt.pvPower}W*\\nGrid: *\${rt.gridPower}W*\${weatherInfo}\\n\\nüïê \${getVietnamTime()}\` 
        });
        notificationFlags[morningKey] = vnDate;
        flagsChanged = true;
      }
    }

    // ‚è∞ B√ÅO C√ÅO M·ªñI GI·ªú - DETAILED v2.7 (like v2.4)
    if (prefs.hourlyStatus && vnHour >= 6 && vnHour <= 21) {
      const hourlyKey = \`hourly_\${chatId}_\${deviceId}_\${vnHour}\`;
      if (notificationFlags[hourlyKey] !== vnDate) {
        const weather = await getWeather(userDevice.location || 'TP. Ho Chi Minh');
        const locationName = userDevice.location || 'TP. Ho Chi Minh';
        const template = getHourlyTemplate(vnHour);
        const weatherTip = getWeatherTip(weather, rt.pvPower);
        
        // PV status tip based on power
        let pvTip = '';
        if (rt.pvPower > 1000) pvTip = '\\n\\nüî• _PV ƒëang "ch√°y" h·∫øt c√¥ng su·∫•t!_';
        else if (rt.pvPower > 500) pvTip = '\\n\\n‚ö° _PV ƒëang ho·∫°t ƒë·ªông m·∫°nh m·∫Ω!_';
        else if (rt.pvPower > 100) pvTip = '\\n\\nüí° _PV ƒëang thu n·∫°p nƒÉng l∆∞·ª£ng!_';
        else if (vnHour < 17 && vnHour >= 6) pvTip = '\\n\\nüí° _Ch·ªù n·∫Øng l√™n ƒë·ªÉ PV ho·∫°t ƒë·ªông_';
        else pvTip = '\\n\\nüåô _PV ngh·ªâ ng∆°i, pin ƒë·∫£m nh·∫≠n!_';
        
        let weatherInfo = '';
        if (weather) {
          weatherInfo = \`\\n\\nüå§Ô∏è *Th·ªùi ti·∫øt \${locationName}:*\\n\${weather.icon} \${weather.currentDescription}\\nüå°Ô∏è \${weather.currentTemp}¬∞C | üíß \${weather.humidity}% | üí® \${weather.windSpeed} km/h\\n\\n\${weatherTip}\`;
        }
        
        notifications.push({ 
          chatId, 
          message: \`\${template.emoji} *\${template.label}*\\n\${template.greeting}\\n\\nüì± *\${deviceId}*\\n‚òÄÔ∏è PV: *\${rt.pvPower}W*\\n\${getBatteryIcon(rt.batterySoc)} Pin: *\${rt.batterySoc}%* \${getBatteryFunStatus(rt.batterySoc)}\\nüè† Load: *\${rt.loadPower}W*\\n‚ö° Grid: *\${rt.gridPower}W* \${getGridIcon(haDevice.hasGridPower)}\${weatherInfo}\${pvTip}\\n\\nüïê \${getVietnamTime()}\` 
        });
        notificationFlags[hourlyKey] = vnDate;
        flagsChanged = true;
      }
    }

    // ‚öôÔ∏è CUSTOM THRESHOLD ALERTS - COMPACT v2.6
    
    // üîãüíö PIN ƒê·∫¶Y - COMPACT
    if (thresholds.batteryFull < 100 && rt.batterySoc >= thresholds.batteryFull) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'full', chatId, deviceId);
      if (alertedValue !== String(thresholds.batteryFull)) {
        notifications.push({ 
          chatId, 
          message: \`üîãüíö *PIN ƒê·∫¶Y*\\nüì± \\\`\${deviceId}\\\`\\n\\nPin: *\${rt.batterySoc}%* (ng∆∞·ª°ng: \${thresholds.batteryFull}%)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'full', chatId, deviceId, thresholds.batteryFull);
        alertsChanged = true;
      }
    }
    
    // ü™´üî¥ PIN TH·∫§P - COMPACT
    if (thresholds.batteryLow > 0 && rt.batterySoc <= thresholds.batteryLow) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'low', chatId, deviceId);
      if (alertedValue !== String(thresholds.batteryLow)) {
        notifications.push({ 
          chatId, 
          message: \`ü™´üî¥ *PIN TH·∫§P*\\nüì± \\\`\${deviceId}\\\`\\n\\nPin: *\${rt.batterySoc}%* (ng∆∞·ª°ng: \${thresholds.batteryLow}%)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'low', chatId, deviceId, thresholds.batteryLow);
        alertsChanged = true;
      }
    }
    
    // üîåüî¥ ƒêI·ªÜN √ÅP CAO - COMPACT
    if (thresholds.batteryVoltHigh > 0 && rt.batteryVoltage >= thresholds.batteryVoltHigh) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'bvhigh', chatId, deviceId);
      if (alertedValue !== String(thresholds.batteryVoltHigh)) {
        notifications.push({ 
          chatId, 
          message: \`üîåüî¥ *ƒêI·ªÜN √ÅP CAO*\\nüì± \\\`\${deviceId}\\\`\\n\\nƒêi·ªán √°p: *\${rt.batteryVoltage}V* (ng∆∞·ª°ng: \${thresholds.batteryVoltHigh}V)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'bvhigh', chatId, deviceId, thresholds.batteryVoltHigh);
        alertsChanged = true;
      }
    }
    
    // üîåüü° ƒêI·ªÜN √ÅP TH·∫§P - COMPACT
    if (thresholds.batteryVoltLow > 0 && rt.batteryVoltage > 0 && rt.batteryVoltage <= thresholds.batteryVoltLow) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'bvlow', chatId, deviceId);
      if (alertedValue !== String(thresholds.batteryVoltLow)) {
        notifications.push({ 
          chatId, 
          message: \`üîåüü° *ƒêI·ªÜN √ÅP TH·∫§P*\\nüì± \\\`\${deviceId}\\\`\\n\\nƒêi·ªán √°p: *\${rt.batteryVoltage}V* (ng∆∞·ª°ng: \${thresholds.batteryVoltLow}V)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'bvlow', chatId, deviceId, thresholds.batteryVoltLow);
        alertsChanged = true;
      }
    }
    
    // ‚òÄÔ∏èüéâ PV ƒê·∫†T NG∆Ø·ª†NG - COMPACT
    if (thresholds.pvDaily > 0 && de.pvDay >= thresholds.pvDaily) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'pv', chatId, deviceId);
      if (alertedValue !== String(thresholds.pvDaily)) {
        notifications.push({ 
          chatId, 
          message: \`‚òÄÔ∏èüéâ *S·∫¢N L∆Ø·ª¢NG PV*\\nüì± \\\`\${deviceId}\\\`\\n\\nPV: *\${de.pvDay}kWh* (ng∆∞·ª°ng: \${thresholds.pvDaily}kWh)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'pv', chatId, deviceId, thresholds.pvDaily);
        alertsChanged = true;
      }
    }
    
    // ‚ö°‚ö†Ô∏è EVN ƒê·∫†T NG∆Ø·ª†NG - COMPACT
    if (thresholds.gridUsage > 0 && de.gridDay >= thresholds.gridUsage) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'grid', chatId, deviceId);
      if (alertedValue !== String(thresholds.gridUsage)) {
        notifications.push({ 
          chatId, 
          message: \`‚ö°‚ö†Ô∏è *ƒêI·ªÜN EVN*\\nüì± \\\`\${deviceId}\\\`\\n\\nEVN: *\${de.gridDay}kWh* (ng∆∞·ª°ng: \${thresholds.gridUsage}kWh)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'grid', chatId, deviceId, thresholds.gridUsage);
        alertsChanged = true;
      }
    }
    
    // üè†üìà TI√äU TH·ª§ ƒê·∫†T NG∆Ø·ª†NG - COMPACT
    if (thresholds.loadDaily > 0 && de.loadDay >= thresholds.loadDaily) {
      const alertedValue = getThresholdAlertKey(thresholdAlerts, 'load', chatId, deviceId);
      if (alertedValue !== String(thresholds.loadDaily)) {
        notifications.push({ 
          chatId, 
          message: \`üè†üìà *TI√äU TH·ª§*\\nüì± \\\`\${deviceId}\\\`\\n\\nTi√™u th·ª•: *\${de.loadDay}kWh* (ng∆∞·ª°ng: \${thresholds.loadDaily}kWh)\\n\\nüïê \${getVietnamTime()}\` 
        });
        setThresholdAlertKey(thresholdAlerts, 'load', chatId, deviceId, thresholds.loadDaily);
        alertsChanged = true;
      }
    }

    currentStates[stateKey] = currentState;
  }

  // Batch save all changes - OPTIMIZATION
  const savePromises = [];
  savePromises.push(saveDeviceStates(env, { ...previousStates, ...currentStates }));
  if (alertsChanged) savePromises.push(saveAllThresholdAlerts(env, thresholdAlerts));
  if (flagsChanged) savePromises.push(saveNotificationFlags(env, notificationFlags));
  await Promise.all(savePromises);
  
  // Send notifications with minimal delay
  for (const notif of notifications) { 
    await sendTelegram(notif.chatId, notif.message, env); 
    await new Promise(r => setTimeout(r, 50)); // Reduced delay
  }
  
  return { sent: notifications.length, checked: devicesData.length, haDevices: haDevices.length };
}


// ============================================
// üìã TELEGRAM COMMAND HANDLERS
// ============================================

async function handleHelp(chatId, devicesData, env) {
  const userDevices = getUserDevices(devicesData, chatId);
  let thresholdsInfo = '';
  
  if (userDevices.length > 0) {
    const th = userDevices[0].thresholds || DEFAULT_THRESHOLDS;
    thresholdsInfo = \`\\n\\n‚öôÔ∏è *Ng∆∞·ª°ng c·∫£nh b√°o:*\\nüîã Pin ƒë·∫ßy: \${th.batteryFull}%\${th.batteryFull >= 100 ? ' ‚ùå' : ' ‚úÖ'}\\nü™´ Pin th·∫•p: \${th.batteryLow}%\\nüîå ƒêi·ªán √°p cao: \${(th.batteryVoltHigh || 0)}V\${(th.batteryVoltHigh || 0) <= 0 ? ' ‚ùå' : ' ‚úÖ'}\\nüîå ƒêi·ªán √°p th·∫•p: \${(th.batteryVoltLow || 0)}V\${(th.batteryVoltLow || 0) <= 0 ? ' ‚ùå' : ' ‚úÖ'}\\n‚òÄÔ∏è PV/ng√†y: \${th.pvDaily}kWh\${th.pvDaily <= 0 ? ' ‚ùå' : ' ‚úÖ'}\\n‚ö° EVN/ng√†y: \${th.gridUsage}kWh\${th.gridUsage <= 0 ? ' ‚ùå' : ' ‚úÖ'}\\nüè† Ti√™u th·ª•/ng√†y: \${th.loadDaily}kWh\${th.loadDaily <= 0 ? ' ‚ùå' : ' ‚úÖ'}\`;
  }
  
  await sendTelegram(chatId, \`ü§ñ *LightEarth Bot v2.7*\\nüìã _Compact Notifications_\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\nüì± *Qu·∫£n l√Ω thi·∫øt b·ªã:*\\n/add <ID> - ‚ûï Th√™m\\n/remove <ID> - ‚ûñ X√≥a\\n/list - üìã Danh s√°ch\\n\\nüìä *Tr·∫°ng th√°i:*\\n/status - üìà T·∫•t c·∫£\\n/check <ID> - üîç Chi ti·∫øt\\n\\n‚öôÔ∏è *C√†i ƒë·∫∑t:*\\n/settings - üîî Th√¥ng b√°o\\n/thresholds - üéØ Ng∆∞·ª°ng\\n/location - üìç V√πng\${thresholdsInfo}\`, env);
}

async function handleThresholds(chatId, args, devicesData, env) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`‚öôÔ∏è *Ng∆∞·ª°ng*\\n\\n_(Ch∆∞a c√≥ thi·∫øt b·ªã)_\\n\\n‚ûï /add\`, env); return; }
  
  if (args.length === 0 && userDevices.length > 1) { 
    let list = \`üéØ *Ng∆∞·ª°ng c·∫£nh b√°o*\\n\\nCh·ªçn thi·∫øt b·ªã:\\n\\n\`; 
    userDevices.forEach((d, i) => { const th = d.thresholds || DEFAULT_THRESHOLDS; list += \`\${i + 1}. üì± \\\`\${d.deviceId}\\\`\\n\`; }); 
    list += \`\\nüìù Nh·∫≠p s·ªë:\`; 
    userStates.set(chatId, { waiting: 'thresholds_device', devices: userDevices.map(d => d.deviceId) }); 
    await sendTelegram(chatId, list, env); 
    return; 
  }
  
  const deviceId = args[0] || userDevices[0].deviceId;
  const device = userDevices.find(d => d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (!device) { await sendTelegram(chatId, \`‚ùå Kh√¥ng t√¨m th·∫•y\`, env); return; }
  
  const th = device.thresholds || DEFAULT_THRESHOLDS;
  userStates.set(chatId, { waiting: 'thresholds_select', deviceId: device.deviceId });
  await sendTelegram(chatId, \`üéØ *Ng∆∞·ª°ng* \\\`\${device.deviceId}\\\`\\n\\n1Ô∏è‚É£ Pin ƒë·∫ßy: *\${th.batteryFull}%* \${th.batteryFull >= 100 ? '‚ùå' : '‚úÖ'}\\n2Ô∏è‚É£ Pin th·∫•p: *\${th.batteryLow}%*\\n3Ô∏è‚É£ ƒêi·ªán √°p cao: *\${(th.batteryVoltHigh || 0)}V* \${(th.batteryVoltHigh || 0) <= 0 ? '‚ùå' : '‚úÖ'}\\n4Ô∏è‚É£ ƒêi·ªán √°p th·∫•p: *\${(th.batteryVoltLow || 0)}V* \${(th.batteryVoltLow || 0) <= 0 ? '‚ùå' : '‚úÖ'}\\n5Ô∏è‚É£ PV/ng√†y: *\${th.pvDaily}kWh* \${th.pvDaily <= 0 ? '‚ùå' : '‚úÖ'}\\n6Ô∏è‚É£ EVN/ng√†y: *\${th.gridUsage}kWh* \${th.gridUsage <= 0 ? '‚ùå' : '‚úÖ'}\\n7Ô∏è‚É£ Ti√™u th·ª•/ng√†y: *\${th.loadDaily}kWh* \${th.loadDaily <= 0 ? '‚ùå' : '‚úÖ'}\\n\\nüìù Nh·∫≠p 1-7 ho·∫∑c 0 tho√°t\`, env);
}

async function handleAdd(chatId, args, env, devicesData) {
  if (args.length === 0) { userStates.set(chatId, { waiting: 'add_device' }); await sendTelegram(chatId, \`‚ûï *Th√™m*\\n\\nüìù Nh·∫≠p Device ID:\`, env); return devicesData; }
  const deviceId = args[0].toUpperCase();
  if (!/^[HP]\\d{6,}\$/.test(deviceId)) { await sendTelegram(chatId, \`‚ùå ID kh√¥ng h·ª£p l·ªá (H/P + s·ªë)\`, env); return devicesData; }
  const haDevices = await fetchAllDevicesFromHA(env);
  if (!haDevices.some(d => d.deviceId?.toUpperCase() === deviceId)) { await sendTelegram(chatId, \`‚ùå \\\`\${deviceId}\\\` ch∆∞a c√≥ trong h·ªá th·ªëng\`, env); return devicesData; }
  const result = await addDevice(env, devicesData, chatId, deviceId);
  await sendTelegram(chatId, result.success ? \`‚úÖ ƒê√£ th√™m \\\`\${deviceId}\\\`\\n\\n‚öôÔ∏è /settings /thresholds /location\` : \`‚ÑπÔ∏è ƒê√£ c√≥\`, env);
  return result.devicesData;
}

async function handleRemove(chatId, args, env, devicesData) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`üìã Ch∆∞a c√≥ thi·∫øt b·ªã\`, env); return devicesData; }
  if (args.length === 0) { let list = \`‚ûñ *X√≥a*\\n\\n\`; userDevices.forEach((d, i) => { list += \`\${i + 1}. \\\`\${d.deviceId}\\\`\\n\`; }); list += \`\\nüìù Nh·∫≠p s·ªë/ID:\`; userStates.set(chatId, { waiting: 'remove_device', devices: userDevices.map(d => d.deviceId) }); await sendTelegram(chatId, list, env); return devicesData; }
  let deviceId = args[0];
  if (/^\\d+\$/.test(deviceId)) { const idx = parseInt(deviceId) - 1; if (idx >= 0 && idx < userDevices.length) deviceId = userDevices[idx].deviceId; }
  const alerts = await loadAllThresholdAlerts(env);
  const result = await removeDevice(env, devicesData, chatId, deviceId, alerts);
  if (result.success) await saveAllThresholdAlerts(env, alerts);
  await sendTelegram(chatId, result.success ? \`‚úÖ ƒê√£ x√≥a \\\`\${deviceId.toUpperCase()}\\\`\` : \`‚ùå Kh√¥ng t√¨m th·∫•y\`, env);
  return result.devicesData;
}

async function handleList(chatId, devicesData, env) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`üìã *Danh s√°ch*\\n\\n_(Tr·ªëng)_\\n\\n‚ûï /add\`, env); return; }
  let msg = \`üìã *Danh s√°ch*\\n\\n\`;
  userDevices.forEach((d, i) => { msg += \`\${i + 1}. \\\`\${d.deviceId}\\\` - \${d.location || "HCM"}\\n\`; });
  await sendTelegram(chatId, msg, env);
}

async function handleStatus(chatId, env, devicesData) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`üìä *Tr·∫°ng th√°i*\\n\\n_(Ch∆∞a c√≥)_\\n\\n‚ûï /add\`, env); return; }
  const haDevices = await fetchAllDevicesFromHA(env);
  let msg = \`üìä *Tr·∫°ng th√°i*\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\`;
  for (const userDevice of userDevices) {
    const haDevice = haDevices.find(d => d.deviceId?.toUpperCase() === userDevice.deviceId.toUpperCase());
    if (haDevice?.realtime) { 
      const rt = haDevice.realtime; 
      msg += \`üì± *\${userDevice.deviceId}* \${haDevice.isOnline ? 'üü¢' : 'üî¥'}\\nPV: \${rt.pvPower}W | Pin: \${rt.batterySoc}%\\nT·∫£i: \${rt.loadPower}W | Grid: \${rt.gridPower}W \${getGridIcon(haDevice.hasGridPower)}\\n\\n\`; 
    }
    else { msg += \`üì± *\${userDevice.deviceId}* ‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu\\n\\n\`; }
  }
  msg += \`üïê \${getVietnamTime()}\`;
  await sendTelegram(chatId, msg, env);
}

async function handleCheck(chatId, args, env) {
  if (args.length === 0) { userStates.set(chatId, { waiting: 'check_device' }); await sendTelegram(chatId, \`üîç *Ki·ªÉm tra*\\n\\nüìù Nh·∫≠p Device ID:\`, env); return; }
  const deviceId = args[0].toUpperCase();
  const haDevices = await fetchAllDevicesFromHA(env);
  const device = haDevices.find(d => d.deviceId?.toUpperCase() === deviceId);
  if (!device) { await sendTelegram(chatId, \`‚ùå Kh√¥ng t√¨m th·∫•y \\\`\${deviceId}\\\`\`, env); return; }
  const rt = device.realtime, de = device.dailyEnergy;
  await sendTelegram(chatId, \`üìä *\${deviceId}* \${device.isOnline ? 'üü¢' : 'üî¥'}\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\nPV: *\${rt.pvPower}W*\\nPin: *\${rt.batterySoc}%* (\${rt.batteryPower}W)\\nT·∫£i: *\${rt.loadPower}W*\\nGrid: *\${rt.gridPower}W* \${device.hasGridPower ? 'üü¢' : 'üî¥'}\\nƒêi·ªán √°p: *\${rt.batteryVoltage}V*\\nNhi·ªát ƒë·ªô: *\${rt.temperature}¬∞C*\\n\\nüìà *H√¥m nay:*\\nPV: \${de.pvDay}kWh\\nT·∫£i: \${de.loadDay}kWh\\nEVN: \${de.gridDay || 0}kWh\\n\\nüïê \${getVietnamTime()}\`, env);
}

async function handleSettings(chatId, args, devicesData, env) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`‚öôÔ∏è *C√†i ƒë·∫∑t*\\n\\n_(Ch∆∞a c√≥)_\\n\\n‚ûï /add\`, env); return; }
  if (args.length === 0 && userDevices.length > 1) { let list = \`üîî *Th√¥ng b√°o*\\n\\nCh·ªçn:\\n\\n\`; userDevices.forEach((d, i) => { list += \`\${i + 1}. \\\`\${d.deviceId}\\\`\\n\`; }); list += \`\\nüìù Nh·∫≠p s·ªë/ID:\`; userStates.set(chatId, { waiting: 'settings_device', devices: userDevices.map(d => d.deviceId) }); await sendTelegram(chatId, list, env); return; }
  const deviceId = args[0] || userDevices[0].deviceId;
  const device = userDevices.find(d => d.deviceId.toUpperCase() === deviceId.toUpperCase());
  if (!device) { await sendTelegram(chatId, \`‚ùå Kh√¥ng t√¨m th·∫•y\`, env); return; }
  const prefs = device.notifications || {};
  const getIcon = (val) => val ? '‚úÖ' : '‚ùå';
  userStates.set(chatId, { waiting: 'settings_toggle', deviceId: device.deviceId });
  await sendTelegram(chatId, \`üîî *Th√¥ng b√°o* \\\`\${device.deviceId}\\\`\\n\\n1Ô∏è‚É£ \${getIcon(prefs.morningGreeting)} Ch√†o bu·ªïi s√°ng\\n2Ô∏è‚É£ \${getIcon(prefs.powerOutage)} M·∫•t ƒëi·ªán\\n3Ô∏è‚É£ \${getIcon(prefs.powerRestored)} C√≥ ƒëi·ªán l·∫°i\\n4Ô∏è‚É£ \${getIcon(prefs.lowBattery)} Pin y·∫øu\\n5Ô∏è‚É£ \${getIcon(prefs.pvEnded)} H·∫øt PV\\n6Ô∏è‚É£ \${getIcon(prefs.hourlyStatus)} M·ªói gi·ªù\\n\\nüìù Nh·∫≠p 1-6 ƒë·ªÉ b·∫≠t/t·∫Øt, 0 tho√°t\`, env);
}

async function handleLocation(chatId, args, devicesData, env) {
  const userDevices = getUserDevices(devicesData, chatId);
  if (userDevices.length === 0) { await sendTelegram(chatId, \`üìç *V√πng*\\n\\n_(Ch∆∞a c√≥)_\\n\\n‚ûï /add\`, env); return; }
  let list = \`üìç *V√πng th·ªùi ti·∫øt*\\n\\nCh·ªçn:\\n\\n\`;
  userDevices.forEach((d, i) => { list += \`\${i + 1}. \\\`\${d.deviceId}\\\` - \${d.location || "HCM"}\\n\`; });
  list += \`\\nüìù Nh·∫≠p s·ªë:\`;
  userStates.set(chatId, { waiting: 'location_select_device', devices: userDevices.map(d => ({ id: d.deviceId, location: d.location })) });
  await sendTelegram(chatId, list, env);
}


// ============================================
// üîó DEEP LINK HANDLER v2.6
// ============================================

async function handleStart(chatId, text, env, devicesData) {
  const payloadMatch = text.match(/\\/start\\s+(.+)/i);
  if (!payloadMatch) {
    await handleHelp(chatId, devicesData, env);
    return devicesData;
  }
  
  const payload = payloadMatch[1].trim();
  const alerts = await loadAllThresholdAlerts(env);
  
  // v2.4+ FORMAT: add_DEVICEID_NNNNNN_bf_bl_pv_gr_ld_bvh_bvl_loc
  const shortMatchV2 = payload.match(/^add_([HP]\\d+)_(\\d{6})_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_([a-z]+)\$/i);
  
  if (shortMatchV2) {
    const [, deviceId, notifBits, bf, bl, pv, gr, ld, vh, vl, locCode] = shortMatchV2;
    const notifications = parseNotificationBits(notifBits);
    const location = decodeLocationCode(locCode);
    const thresholds = {
      batteryFull: parseInt(bf),
      batteryLow: parseInt(bl),
      pvDaily: parseInt(pv),
      gridUsage: parseInt(gr),
      loadDaily: parseInt(ld),
      batteryVoltHigh: parseInt(vh) / 10,
      batteryVoltLow: parseInt(vl) / 10
    };
    
    const haDevices = await fetchAllDevicesFromHA(env);
    if (!haDevices.find(d => d.deviceId?.toUpperCase() === deviceId.toUpperCase())) {
      await sendTelegram(chatId, \`‚ùå \\\`\${deviceId.toUpperCase()}\\\` ch∆∞a c√≥ trong h·ªá th·ªëng\`, env);
      return devicesData;
    }
    
    const result = await addDeviceWithSettings(env, devicesData, chatId, deviceId.toUpperCase(), notifications, location, thresholds, alerts);
    await saveAllThresholdAlerts(env, alerts);
    
    const action = result.isNew ? '‚úÖ *TH√äM M·ªöI*' : '‚úÖ *C·∫¨P NH·∫¨T*';
    await sendTelegram(chatId, \`\${action}\\n\\nüì± \\\`\${deviceId.toUpperCase()}\\\`\\nüìç \${location}\\n\\nüéØ Pin ƒë·∫ßy: \${thresholds.batteryFull}% | Pin th·∫•p: \${thresholds.batteryLow}%\\nüîå ƒêi·ªán √°p: \${thresholds.batteryVoltHigh}V / \${thresholds.batteryVoltLow}V\\n‚òÄÔ∏è PV: \${thresholds.pvDaily}kWh | ‚ö° EVN: \${thresholds.gridUsage}kWh | üè† T·∫£i: \${thresholds.loadDaily}kWh\\n\\n‚öôÔ∏è /settings /thresholds /location\`, env);
    return result.devicesData;
  }
  
  // LEGACY v1.9.0 FORMAT: add_DEVICEID_NNNNNN_bf_bl_pv_gr_ld_loc
  const shortMatch = payload.match(/^add_([HP]\\d+)_(\\d{6})_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_([a-z]+)\$/i);
  
  if (shortMatch) {
    const [, deviceId, notifBits, bf, bl, pv, gr, ld, locCode] = shortMatch;
    const notifications = parseNotificationBits(notifBits);
    const location = decodeLocationCode(locCode);
    const thresholds = {
      batteryFull: parseInt(bf),
      batteryLow: parseInt(bl),
      pvDaily: parseInt(pv),
      gridUsage: parseInt(gr),
      loadDaily: parseInt(ld),
      batteryVoltHigh: 0,
      batteryVoltLow: 0
    };
    
    const haDevices = await fetchAllDevicesFromHA(env);
    if (!haDevices.find(d => d.deviceId?.toUpperCase() === deviceId.toUpperCase())) {
      await sendTelegram(chatId, \`‚ùå \\\`\${deviceId.toUpperCase()}\\\` ch∆∞a c√≥ trong h·ªá th·ªëng\`, env);
      return devicesData;
    }
    
    const result = await addDeviceWithSettings(env, devicesData, chatId, deviceId.toUpperCase(), notifications, location, thresholds, alerts);
    await saveAllThresholdAlerts(env, alerts);
    
    const action = result.isNew ? '‚úÖ *TH√äM M·ªöI*' : '‚úÖ *C·∫¨P NH·∫¨T*';
    await sendTelegram(chatId, \`\${action}\\n\\nüì± \\\`\${deviceId.toUpperCase()}\\\`\\nüìç \${location}\\n\\n‚öôÔ∏è /settings /thresholds /location\`, env);
    return result.devicesData;
  }
  
  // Simple format: add_DEVICEID
  const addMatch = payload.match(/^add_([HP]\\d+)/i);
  
  if (addMatch) {
    const deviceId = addMatch[1].toUpperCase();
    
    const haDevices = await fetchAllDevicesFromHA(env);
    if (!haDevices.find(d => d.deviceId?.toUpperCase() === deviceId)) {
      await sendTelegram(chatId, \`‚ùå \\\`\${deviceId}\\\` ch∆∞a c√≥ trong h·ªá th·ªëng\`, env);
      return devicesData;
    }
    
    const result = await addDevice(env, devicesData, chatId, deviceId);
    
    const action = result.success ? '‚úÖ *TH√äM M·ªöI*' : '‚ÑπÔ∏è *ƒê√É C√ì*';
    await sendTelegram(chatId, \`\${action}\\n\\nüì± \\\`\${deviceId}\\\`\\n\\n‚öôÔ∏è /settings /thresholds /location\`, env);
    return result.devicesData;
  }
  
  await handleHelp(chatId, devicesData, env);
  return devicesData;
}

// ============================================
// üí¨ CONVERSATION HANDLER
// ============================================

async function handleConversation(chatId, text, env, devicesData) {
  const state = userStates.get(chatId);
  if (!state) return { handled: false, devicesData };
  userStates.delete(chatId);
  const alerts = await loadAllThresholdAlerts(env);

  switch (state.waiting) {
    case 'add_device': return { handled: true, devicesData: await handleAdd(chatId, [text], env, devicesData) };
    case 'remove_device': 
      let deviceId = text; 
      if (/^\\d+\$/.test(text) && state.devices) { const idx = parseInt(text) - 1; if (idx >= 0 && idx < state.devices.length) deviceId = state.devices[idx]; } 
      return { handled: true, devicesData: await handleRemove(chatId, [deviceId], env, devicesData) };
    case 'check_device': await handleCheck(chatId, [text], env); return { handled: true, devicesData };
    case 'settings_device': 
      let selectedDevice = text; 
      if (/^\\d+\$/.test(text) && state.devices) { const idx = parseInt(text) - 1; if (idx >= 0 && idx < state.devices.length) selectedDevice = state.devices[idx]; } 
      await handleSettings(chatId, [selectedDevice], devicesData, env); 
      return { handled: true, devicesData };
    case 'settings_toggle':
      if (text === '0') { await sendTelegram(chatId, \`üö™ Tho√°t\`, env); return { handled: true, devicesData }; }
      const settingNum = parseInt(text);
      if (settingNum >= 1 && settingNum <= 6) { 
        const result = await updateDeviceSettings(env, devicesData, chatId, state.deviceId, settingNum); 
        if (result) { 
          const settingNames = { morningGreeting: "Ch√†o bu·ªïi s√°ng", powerOutage: "M·∫•t ƒëi·ªán", powerRestored: "C√≥ ƒëi·ªán l·∫°i", lowBattery: "Pin y·∫øu", pvEnded: "H·∫øt PV", hourlyStatus: "M·ªói gi·ªù" }; 
          await sendTelegram(chatId, \`‚úÖ \${settingNames[result.setting]}: \${result.newValue ? "B·∫¨T" : "T·∫ÆT"}\\n\\nüìù Ti·∫øp t·ª•c (1-6) ho·∫∑c 0 tho√°t\`, env); 
          userStates.set(chatId, { waiting: 'settings_toggle', deviceId: state.deviceId }); 
        } 
      } else { 
        await sendTelegram(chatId, \`‚ùå Nh·∫≠p 1-6 ho·∫∑c 0\`, env); 
        userStates.set(chatId, state); 
      }
      return { handled: true, devicesData };
    
    case 'thresholds_device':
      const thDevIdx = parseInt(text) - 1;
      if (thDevIdx >= 0 && thDevIdx < state.devices.length) {
        await handleThresholds(chatId, [state.devices[thDevIdx]], devicesData, env);
      } else {
        await sendTelegram(chatId, \`‚ùå Kh√¥ng h·ª£p l·ªá. /thresholds\`, env);
      }
      return { handled: true, devicesData };
    
    case 'thresholds_select':
      if (text === '0') { await sendTelegram(chatId, \`üö™ Tho√°t\`, env); return { handled: true, devicesData }; }
      const thNum = parseInt(text);
      if (thNum >= 1 && thNum <= 7) {
        const thNames = { 1: 'batteryFull', 2: 'batteryLow', 3: 'batteryVoltHigh', 4: 'batteryVoltLow', 5: 'pvDaily', 6: 'gridUsage', 7: 'loadDaily' };
        const thLabels = { 1: 'Pin ƒë·∫ßy (%)', 2: 'Pin th·∫•p (%)', 3: 'ƒêi·ªán √°p cao (V)', 4: 'ƒêi·ªán √°p th·∫•p (V)', 5: 'PV/ng√†y (kWh)', 6: 'EVN/ng√†y (kWh)', 7: 'Ti√™u th·ª•/ng√†y (kWh)' };
        userStates.set(chatId, { waiting: 'thresholds_input', deviceId: state.deviceId, thresholdKey: thNames[thNum] });
        await sendTelegram(chatId, \`*\${thLabels[thNum]}*\\n\\nüìù Nh·∫≠p gi√° tr·ªã (0 = T·∫ÆT):\`, env);
      } else {
        await sendTelegram(chatId, \`‚ùå Nh·∫≠p 1-7 ho·∫∑c 0\`, env);
        userStates.set(chatId, state);
      }
      return { handled: true, devicesData };
    
    case 'thresholds_input':
      const isVoltageType = ['batteryVoltHigh', 'batteryVoltLow'].includes(state.thresholdKey);
      const normalizedText = text.replace(',', '.');
      const value = isVoltageType ? parseFloat(normalizedText) : parseInt(normalizedText);
      if (isNaN(value) || value < 0) {
        await sendTelegram(chatId, \`‚ùå Gi√° tr·ªã kh√¥ng h·ª£p l·ªá (‚â•0)\`, env);
        userStates.set(chatId, state);
        return { handled: true, devicesData };
      }
      const newTh = { [state.thresholdKey]: value };
      await updateDeviceThresholds(env, devicesData, chatId, state.deviceId, newTh, alerts);
      await saveAllThresholdAlerts(env, alerts);
      const thLabelMap = { batteryFull: 'Pin ƒë·∫ßy', batteryLow: 'Pin th·∫•p', pvDaily: 'PV/ng√†y', gridUsage: 'EVN/ng√†y', loadDaily: 'Ti√™u th·ª•/ng√†y', batteryVoltHigh: 'ƒêi·ªán √°p cao', batteryVoltLow: 'ƒêi·ªán √°p th·∫•p' };
      const unitMap = { batteryFull: '%', batteryLow: '%', pvDaily: 'kWh', gridUsage: 'kWh', loadDaily: 'kWh', batteryVoltHigh: 'V', batteryVoltLow: 'V' };
      await sendTelegram(chatId, \`‚úÖ \${thLabelMap[state.thresholdKey]}: *\${value}\${unitMap[state.thresholdKey]}*\\n\\n‚öôÔ∏è /thresholds\`, env);
      return { handled: true, devicesData };
    
    case 'location_select_device':
      const devIdx = parseInt(text) - 1;
      if (devIdx >= 0 && devIdx < state.devices.length) {
        const selectedDev = state.devices[devIdx];
        userStates.set(chatId, { waiting: 'location_select_region', deviceId: selectedDev.id, currentLocation: selectedDev.location });
        await sendTelegram(chatId, \`üì± \\\`\${selectedDev.id}\\\`\\n\\n1Ô∏è‚É£ Mi·ªÅn Nam\\n2Ô∏è‚É£ Mi·ªÅn Trung\\n3Ô∏è‚É£ T√¢y Nguy√™n\\n4Ô∏è‚É£ Mi·ªÅn B·∫Øc\\n\\nüìù Nh·∫≠p 1-4:\`, env);
      } else {
        await sendTelegram(chatId, \`‚ùå Kh√¥ng h·ª£p l·ªá. /location\`, env);
      }
      return { handled: true, devicesData };
    
    case 'location_select_region':
      const regionNum = parseInt(text);
      if (regionNum >= 1 && regionNum <= 4) { 
        const regionMap = { 1: "Mien Nam", 2: "Mien Trung", 3: "Tay Nguyen", 4: "Mien Bac" }; 
        const regionNames = { 1: "Mi·ªÅn Nam", 2: "Mi·ªÅn Trung", 3: "T√¢y Nguy√™n", 4: "Mi·ªÅn B·∫Øc" };
        const region = regionMap[regionNum]; 
        const cities = Object.entries(VIETNAM_CITIES).filter(([_, d]) => d.region === region).map(([name]) => name).sort(); 
        let message = \`üå¥ *\${regionNames[regionNum]}*\\n\\n\`; 
        cities.forEach((city, i) => { message += \`\${i + 1}. \${city}\\n\`; }); 
        message += \`\\nüìù Nh·∫≠p s·ªë (1-\${cities.length}):\`; 
        userStates.set(chatId, { waiting: 'location_select_city', deviceId: state.deviceId, cities }); 
        await sendTelegram(chatId, message, env); 
      } else { 
        await sendTelegram(chatId, \`‚ùå Nh·∫≠p 1-4\`, env); 
        userStates.set(chatId, state); 
      }
      return { handled: true, devicesData };
    
    case 'location_select_city':
      let selectedCity = null;
      if (/^\\d+\$/.test(text) && state.cities) { const idx = parseInt(text) - 1; if (idx >= 0 && idx < state.cities.length) selectedCity = state.cities[idx]; }
      else { selectedCity = Object.keys(VIETNAM_CITIES).find(c => c.toLowerCase().includes(text.toLowerCase())); }
      if (selectedCity && VIETNAM_CITIES[selectedCity]) { 
        await updateSingleDeviceLocation(env, devicesData, chatId, state.deviceId, selectedCity); 
        await sendTelegram(chatId, \`‚úÖ \\\`\${state.deviceId}\\\` ‚Üí *\${selectedCity}*\`, env); 
      } else { 
        await sendTelegram(chatId, \`‚ùå Kh√¥ng t√¨m th·∫•y. /location\`, env); 
      }
      return { handled: true, devicesData };
  }
  return { handled: false, devicesData };
}


// ============================================
// üîÑ UPDATE HANDLER
// ============================================

async function handleUpdate(update, env) {
  if (!update.message?.text) return;
  const chatId = update.message.chat.id;
  const text = update.message.text.trim();
  let devicesData = await loadDevicesData(env);
  
  if (!text.startsWith('/')) { 
    await handleConversation(chatId, text, env, devicesData); 
    return; 
  }
  
  userStates.delete(chatId);
  const parts = text.split(/\\s+/);
  const command = parts[0].toLowerCase().split('@')[0];
  const args = parts.slice(1);
  
  switch (command) {
    case '/start': await handleStart(chatId, text, env, devicesData); break;
    case '/help': await handleHelp(chatId, devicesData, env); break;
    case '/add': await handleAdd(chatId, args, env, devicesData); break;
    case '/remove': case '/delete': await handleRemove(chatId, args, env, devicesData); break;
    case '/list': await handleList(chatId, devicesData, env); break;
    case '/status': await handleStatus(chatId, env, devicesData); break;
    case '/check': await handleCheck(chatId, args, env); break;
    case '/settings': case '/caidat': await handleSettings(chatId, args, devicesData, env); break;
    case '/thresholds': case '/nguong': await handleThresholds(chatId, args, devicesData, env); break;
    case '/location': case '/vung': case '/vitri': await handleLocation(chatId, args, devicesData, env); break;
    default: await sendTelegram(chatId, \`‚ùì L·ªánh kh√¥ng h·ª£p l·ªá. /help\`, env);
  }
}

// ============================================
// üåê CLOUDFLARE WORKER EXPORT
// ============================================

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    if (request.method === 'OPTIONS') return corsResponse(null, { status: 204 });
    
    // Get bot token from env or default
    const token = env.BOT_TOKEN || BOT_TOKEN;
    const telegramApi = 'https://api.telegram.org/bot' + token;
    
    // ============================================
    // üîß WEBHOOK SETUP
    // ============================================
    if (url.pathname === '/setup-webhook') { 
      const webhookUrl = url.origin + '/webhook'; 
      const webhookResp = await fetch(telegramApi + '/setWebhook', { 
        method: 'POST', 
        headers: { 'Content-Type': 'application/json' }, 
        body: JSON.stringify({ url: webhookUrl }) 
      }); 
      const commands = [
        { command: 'start', description: 'üöÄ B·∫Øt ƒë·∫ßu' },
        { command: 'help', description: 'üìã H∆∞·ªõng d·∫´n' },
        { command: 'add', description: 'üì± Th√™m thi·∫øt b·ªã' },
        { command: 'remove', description: 'üóëÔ∏è X√≥a thi·∫øt b·ªã' },
        { command: 'list', description: 'üìã Danh s√°ch' },
        { command: 'status', description: 'üìä Tr·∫°ng th√°i' },
        { command: 'check', description: 'üîç Ki·ªÉm tra' },
        { command: 'settings', description: 'üîî Th√¥ng b√°o' },
        { command: 'thresholds', description: 'üéØ Ng∆∞·ª°ng' },
        { command: 'location', description: 'üìç V√πng' }
      ];
      const cmdResp = await fetch(telegramApi + '/setMyCommands', { 
        method: 'POST', 
        headers: { 'Content-Type': 'application/json' }, 
        body: JSON.stringify({ commands }) 
      });
      return jsonResponse({ webhook: await webhookResp.json(), commands: await cmdResp.json(), webhookUrl }); 
    }
    
    // ============================================
    // üì© WEBHOOK HANDLER
    // ============================================
    if (url.pathname === '/webhook' && request.method === 'POST') { 
      try { 
        ctx.waitUntil(handleUpdate(await request.json(), env)); 
        return corsResponse('OK'); 
      } catch (e) { 
        return corsResponse('Error', { status: 500 }); 
      } 
    }
    
    // ============================================
    // üß™ TEST & DEBUG ENDPOINTS
    // ============================================
    if (url.pathname === '/test-api') { 
      const devices = await fetchAllDevicesFromHA(env); 
      return jsonResponse({ 
        success: true, 
        source: 'Direct_HA', 
        count: devices.length, 
        deviceIds: devices.slice(0, 10).map(d => d.deviceId) 
      }); 
    }
    
    if (url.pathname === '/trigger-notifications') { 
      return jsonResponse({ 
        success: true, 
        ...(await processNotifications(env)), 
        timestamp: getVietnamTime() 
      }); 
    }
    
    // ============================================
    // üì± DEVICE SETTINGS API
    // ============================================
    if (url.pathname === '/api/device-settings') {
      const deviceId = url.searchParams.get('deviceId');
      if (!deviceId) return jsonResponse({ success: false, error: 'deviceId required' });
      const devicesData = await loadDevicesData(env);
      const device = devicesData.find(d => d.deviceId.toUpperCase() === deviceId.toUpperCase());
      if (!device) return jsonResponse({ success: false, error: 'Device not found', deviceId });
      return jsonResponse({ 
        success: true, 
        deviceId: device.deviceId, 
        location: device.location, 
        settings: device.notifications, 
        thresholds: device.thresholds || DEFAULT_THRESHOLDS, 
        addedAt: device.addedAt 
      });
    }
    
    if (url.pathname === '/api/update-settings' && request.method === 'POST') {
      try {
        const body = await request.json();
        const { deviceId, notifications, location, thresholds, chatId } = body;
        if (!deviceId) return jsonResponse({ success: false, error: 'deviceId required' });
        
        let devicesData = await loadDevicesData(env);
        let device = devicesData.find(d => d.deviceId.toUpperCase() === deviceId.toUpperCase());
        const alerts = await loadAllThresholdAlerts(env);
        
        if (!device && chatId) {
          device = {
            deviceId: deviceId.toUpperCase(),
            chatId: parseInt(chatId),
            addedAt: getVietnamTime(),
            location: location || "TP. Ho Chi Minh",
            notifications: notifications || { morningGreeting: true, powerOutage: true, powerRestored: true, lowBattery: true, pvEnded: true, hourlyStatus: false },
            thresholds: thresholds || { ...DEFAULT_THRESHOLDS }
          };
          devicesData.push(device);
        } else if (!device) {
          return jsonResponse({ success: false, error: 'Device not found' });
        }
        
        if (notifications) device.notifications = { ...device.notifications, ...notifications };
        if (location) device.location = location;
        if (thresholds) {
          const oldThresholds = device.thresholds || { ...DEFAULT_THRESHOLDS };
          device.thresholds = { ...oldThresholds, ...thresholds };
          clearAllThresholdAlertsForDevice(alerts, device.chatId, device.deviceId.toUpperCase());
          await saveAllThresholdAlerts(env, alerts);
        }
        
        await saveDevicesData(env, devicesData);
        return jsonResponse({ 
          success: true, 
          message: 'Updated', 
          deviceId: device.deviceId, 
          notifications: device.notifications, 
          location: device.location, 
          thresholds: device.thresholds, 
          thresholdsReset: !!thresholds 
        });
      } catch (e) {
        return jsonResponse({ success: false, error: e.message });
      }
    }
    
    // ============================================
    // üîó DEEP LINK GENERATOR API
    // ============================================
    if (url.pathname === '/api/generate-deeplink') {
      const deviceId = url.searchParams.get('deviceId');
      const notifs = url.searchParams.get('notifications') || '111110';
      const bf = url.searchParams.get('bf') || '100';
      const bl = url.searchParams.get('bl') || '20';
      const pv = url.searchParams.get('pv') || '0';
      const gr = url.searchParams.get('gr') || '0';
      const ld = url.searchParams.get('ld') || '0';
      const vh = url.searchParams.get('vh') || '0';
      const vl = url.searchParams.get('vl') || '0';
      const loc = url.searchParams.get('loc') || 'hcm';
      
      if (!deviceId) return jsonResponse({ success: false, error: 'deviceId required' });
      
      const shortLink = \`add_\${deviceId.toUpperCase()}_\${notifs}_\${bf}_\${bl}_\${pv}_\${gr}_\${ld}_\${vh}_\${vl}_\${loc}\`;
      const telegramUrl = \`https://t.me/LightEarthBot?start=\${shortLink}\`;
      
      return jsonResponse({ 
        success: true, 
        shortLink,
        telegramUrl,
        length: shortLink.length,
        maxLength: 64,
        valid: shortLink.length <= 64
      });
    }
    
    // ============================================
    // üå§Ô∏è WEATHER TEST
    // ============================================
    if (url.pathname === '/test-weather') {
      const location = url.searchParams.get('location') || 'TP. Ho Chi Minh';
      try { 
        const weather = await getWeather(location); 
        return jsonResponse({ success: !!weather, location, weather: weather || 'Failed', timestamp: getVietnamTime() }); 
      } catch (e) { 
        return jsonResponse({ success: false, error: e.message, location }); 
      }
    }
    
    // ============================================
    // üì¶ KV STATUS & BACKUP
    // ============================================
    if (url.pathname === '/kv-status') { 
      const hasKV = !!env.BOT_KV; 
      let count = 0, states = null; 
      if (hasKV) { 
        try { 
          const data = await env.BOT_KV.get(KV_KEYS.DEVICES, { type: 'json' }); 
          states = await env.BOT_KV.get(KV_KEYS.DEVICE_STATES, { type: 'json' }); 
          count = data?.length || 0; 
        } catch (e) {} 
      } 
      return jsonResponse({ kvBound: hasKV, usersCount: count, statesTracked: states ? Object.keys(states).length : 0, message: hasKV ? 'KV active' : 'KV not bound' }); 
    }
    
    if (url.pathname === '/kv-backup') { 
      if (!env.BOT_KV) return jsonResponse({ error: 'KV not bound' }, 400); 
      return jsonResponse({ backup: await env.BOT_KV.get(KV_KEYS.DEVICES, { type: 'json' }), timestamp: new Date().toISOString() }); 
    }
    
    // ============================================
    // ‚ù§Ô∏è HEALTH CHECK
    // ============================================
    if (url.pathname === '/health') { 
      const hasKV = !!env.BOT_KV; 
      let count = 0; 
      if (hasKV) { 
        const data = await env.BOT_KV.get(KV_KEYS.DEVICES, { type: 'json' }); 
        count = data?.length || 0; 
      } 
      return jsonResponse({ 
        status: 'ok', 
        version: '2.7', 
        features: [
          'Compact Notifications', 
          'Voltage Alerts', 
          'Short Deep Link ‚â§64', 
          'Smart Thresholds', 
          'Alert Once', 
          'Weather Cache',
          'Batch KV'
        ], 
        mode: 'Direct_HA', 
        storage: hasKV ? 'KV_Persistent' : 'In-Memory', 
        notifications: 'enabled', 
        webAPI: 'enabled', 
        users: count 
      }); 
    }
    
    // ============================================
    // üè† DEFAULT HTML PAGE
    // ============================================
    return corsResponse(\`<!DOCTYPE html><html><head><meta charset="UTF-8"><title>LightEarth Bot v2.7</title><style>body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;max-width:700px;margin:50px auto;padding:20px;background:#0f172a;color:#e2e8f0}h1{color:#22d3ee}h2{color:#a78bfa;border-bottom:1px solid #334155;padding-bottom:10px}ul{list-style:none;padding-left:0}li{padding:8px 0;border-bottom:1px solid #1e293b}a{color:#22d3ee;text-decoration:none}.badge{background:#059669;color:white;padding:3px 8px;border-radius:4px;font-size:12px;margin-right:5px}.code{background:#1e293b;padding:8px 12px;border-radius:4px;font-family:monospace;font-size:13px;display:block;margin:10px 0}</style></head><body><h1>ü§ñ LightEarth Bot v2.7</h1><p><span class="badge">üìã Compact</span><span class="badge">‚ö° Voltage</span><span class="badge">üîó Deep Link</span></p><h2>üìã Th√¥ng b√°o g·ªçn v2.6:</h2><p>‚úÖ Pin ƒë·∫ßy: 97%<br>‚ö†Ô∏è Pin th·∫•p: 20%<br>üî¥ ƒêi·ªán √°p cao: 54.5V<br>üü° ƒêi·ªán √°p th·∫•p: 51V<br>‚òÄÔ∏è S·∫£n l∆∞·ª£ng PV: 25kWh<br>‚ö° ƒêi·ªán EVN: 25kWh<br>üè† Ti√™u th·ª•: 25kWh</p><h2>üì± Commands:</h2><ul><li>/status - Tr·∫°ng th√°i</li><li>/check - Ki·ªÉm tra chi ti·∫øt</li><li>/settings - Th√¥ng b√°o</li><li>/thresholds - Ng∆∞·ª°ng</li><li>/location - V√πng</li></ul><h2>üîß API:</h2><ul><li><a href="/health">/health</a></li><li><a href="/trigger-notifications">/trigger-notifications</a></li><li><a href="/kv-status">/kv-status</a></li></ul></body></html>\`, { headers: { 'Content-Type': 'text/html; charset=utf-8' } });
  },
  
  // ============================================
  // ‚è∞ CRON TRIGGER
  // ============================================
  async scheduled(event, env, ctx) { 
    ctx.waitUntil(processNotifications(env)); 
  }
};
`;
    
    document.getElementById('code-content').textContent = fullCode;
    
    function copyCode() {
      navigator.clipboard.writeText(fullCode).then(() => {
        const btn = document.querySelector('.copy-btn');
        btn.textContent = '‚úÖ ƒê√£ Copy!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'üìã Copy Full Code';
          btn.classList.remove('copied');
        }, 3000);
      }).catch(err => {
        // Fallback
        const textarea = document.createElement('textarea');
        textarea.value = fullCode;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        
        const btn = document.querySelector('.copy-btn');
        btn.textContent = '‚úÖ ƒê√£ Copy!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'üìã Copy Full Code';
          btn.classList.remove('copied');
        }, 3000);
      });
    }
  </script>
</body>
</html>
